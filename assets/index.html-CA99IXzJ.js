import{_ as s,c as a,d as e,o as p}from"./app-DqqFfEKg.js";const l={};function c(i,n){return p(),a("div",null,n[0]||(n[0]=[e(`<h1 id="你不知道的js-摘录-起步上路" tabindex="-1"><a class="header-anchor" href="#你不知道的js-摘录-起步上路"><span>你不知道的JS-摘录-起步上路</span></a></h1><p>顺便读一读<a href="https://github.com/getify/You-Dont-Know-JS" target="_blank" rel="noopener noreferrer">You-Dont-Know-JS</a>，把一些我觉得对我比较有启发的语句摘录下来，很多重要的内容我都没有摘抄，只是因为相对而言我对它们比较熟悉，摘抄的主要是我不熟悉甚至不知道的内容，并不是说没有摘抄的内容就不重要。</p><p>另外，在极少数我觉得需要补充的地方会写一些内容，但大多数时候原内容就已经足够简单易懂了，所以基本都是摘抄</p><p>ps:目前摘录内容较少，暂时不加入侧边栏，只从顶部栏进入查看效果。等读的差不多了再放进侧边栏</p><h2 id="第二章-值与类型" tabindex="-1"><a class="header-anchor" href="#第二章-值与类型"><span>第二章-值与类型：</span></a></h2><p>在JavaScript中只有值拥有类型；变量只是这些值的简单容器。</p><p><code>typeof null</code>是一个有趣的例子，因为当你期望它返回<code>&quot;null&quot;</code>时，它错误地返回了<code>&quot;object&quot;</code>。这是JS中一直存在的一个bug，但是看起来它永远都不会被修复了。在网络上有太多的代码依存于这个bug，因此修复它将会导致更多的bug！</p><h3 id="值的比较" tabindex="-1"><a class="header-anchor" href="#值的比较"><span>值的比较</span></a></h3><h4 id="truthy-与-falsy" tabindex="-1"><a class="header-anchor" href="#truthy-与-falsy"><span>Truthy 与 Falsy</span></a></h4><p>当一个非<code>boolean</code>值被强制转换为一个<code>boolean</code>时，它是变成<code>true</code>还是<code>false</code>。</p><p>在JavaScript中“falsy”的明确列表如下：</p><ul><li><code>&quot;&quot;</code> （空字符串）</li><li><code>0</code>, <code>-0</code>, <code>NaN</code> （非法的<code>number</code>）</li><li><code>null</code>, <code>undefined</code></li><li><code>false</code></li></ul><p>任何不在这个“falsy”列表中的值都是“truthy”。</p><h4 id="等价性" tabindex="-1"><a class="header-anchor" href="#等价性"><span>等价性</span></a></h4><p><code>==</code>和<code>===</code>之间的不同通常被描述为，<code>==</code>检查值的等价性而<code>===</code>检查值和类型两者的等价性。然而，这是不准确的。描述它们的合理方式是，<code>==</code>在允许强制转换的条件下检查值的等价性，而<code>===</code>是在不允许强制转换的条件下检查值的等价性；因此<code>===</code>常被称为“严格等价”。</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">这个部分我自己想补充一下==比较的流程的总结：</span>
<span class="line">==从上到下按照规则比较，直到能得到确切结果为止</span>
<span class="line">1.两端类型相同，比较值</span>
<span class="line">2.两端存在NaN，返回false</span>
<span class="line">3. undefined和null只有与自身比较，或者互相比较时，才会返回true</span>
<span class="line">4.两端都是原始类型，转换成数字比较</span>
<span class="line">5.一端是原始类型，一端是对象类型，把对象转换成原始类型后进入第1步</span>
<span class="line">6.两端都是对象类型直接比较引用地址是否相同</span>
<span class="line">注意直接开辟的[]、{}都会在内存中开辟一块空间，因此[]==[];{}=={}都不会相等</span>
<span class="line"></span>
<span class="line">也就是先看类型，相同直接比；</span>
<span class="line">不同的话，看看有没有NaN，有的话直接false；</span>
<span class="line">没有再看类型有没有对象，</span>
<span class="line">    有且仅有一个的话对对象进行处理成原始类型比较；</span>
<span class="line">        两个都是对象直接比引用地址是否相同；</span>
<span class="line">    没有的话转数字再比较；</span>
<span class="line">注意undefined和null的比较情况。</span>
<span class="line"></span>
<span class="line">对象如何转原始类型？下面的得不到原始值就是return {}；</span>
<span class="line">另外还有需要注意的地方，{}经过valueOf得到的还是对象，经过toString得到的是&#39;[object Object]&#39;，</span>
<span class="line">因此({})==&quot;&quot;是false，而[]==&quot;&quot;是true</span>
<span class="line">1.如果对象拥有[Symbol.toPrimitive]方法，调用该方法。</span>
<span class="line">若该方法能得到原始值，使用该原始值；</span>
<span class="line">若得不到原始值，抛出异常</span>
<span class="line">2.调用对象的value0f方法</span>
<span class="line">若该方法能得到原始值，使用该原始值；</span>
<span class="line">若得不到原始值，进入下一步</span>
<span class="line">3.调用对象的toString方法</span>
<span class="line">若该方法能得到原始值，使用该原始值;</span>
<span class="line">若得不到原始值，抛出异常</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了将这许多细节归纳为一个简单的包装，并帮助你在各种情况下判断是否使用<code>==</code>或<code>===</code>，这是我的简单规则：</p><ul><li>如果一个比较的两个值之一可能是<code>true</code>或<code>false</code>值，避免<code>==</code>而使用<code>===</code>。</li><li>如果一个比较的两个值之一可能是这些具体的值（<code>0</code>，<code>&quot;&quot;</code>，或<code>[]</code> —— 空数组），避免<code>==</code>而使用<code>===</code>。</li><li>在 <em>所有</em> 其他情况下，你使用<code>==</code>是安全的。它不仅安全，而且在许多情况下它可以简化你的代码并改善可读性。</li></ul><p>这些规则归纳出来的东西要求你严谨地考虑你的代码：什么样的值可能通过这个被比较等价性的变量。如果你可以确定这些值，那么<code>==</code>就是安全的，使用它！如果你不能确定这些值，就使用<code>===</code>。就这么简单。</p><h4 id="不等价性" tabindex="-1"><a class="header-anchor" href="#不等价性"><span>不等价性</span></a></h4><p>JavaScript<code>string</code>值也可进行不等价性比较，它使用典型的字母顺序规则（<code>&quot;bar&quot; &lt; &quot;foo&quot;</code>）。</p><p>在可能不同类型的值之间进行比较时，你可能遇到的最大的坑 —— 记住，没有“严格不等价”可用 —— 是其中一个值不能转换为合法的数字，例如：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token string">&quot;foo&quot;</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">a <span class="token operator">&lt;</span> b<span class="token punctuation">;</span>		<span class="token comment">// false</span></span>
<span class="line">a <span class="token operator">&gt;</span> b<span class="token punctuation">;</span>		<span class="token comment">// false</span></span>
<span class="line">a <span class="token operator">==</span> b<span class="token punctuation">;</span>		<span class="token comment">// false</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>等一下，这三个比较怎么可能都是<code>false</code>？因为在<code>&lt;</code>和<code>&gt;</code>的比较中，值<code>b</code>被强制转换为了“非法的数字值”，而且语言规范说<code>NaN</code>既不大于其他值，也不小于其他值。</p><h2 id="第二章-strict模式" tabindex="-1"><a class="header-anchor" href="#第二章-strict模式"><span>第二章-Strict模式</span></a></h2><p>ES5在语言中加入了一个“strict模式”，它收紧了一些特定行为的规则。</p><p>使用strict模式的一个关键不同（改善！）是，它不允许因为省略了<code>var</code>而进行隐含的自动全局变量声明：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">	<span class="token string">&quot;use strict&quot;</span><span class="token punctuation">;</span>	<span class="token comment">// 打开strict模式</span></span>
<span class="line">	a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>			<span class="token comment">// 缺少\`var\`，ReferenceError</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="第二章-旧的与新的" tabindex="-1"><a class="header-anchor" href="#第二章-旧的与新的"><span>第二章-旧的与新的</span></a></h2><h3 id="转译" tabindex="-1"><a class="header-anchor" href="#转译"><span>转译</span></a></h3><p>实质上，你的源代码是使用新的语法形式编写的，但是你向浏览器部署的是转译过的旧语法形式。你一般会将转译器插入到你的构建过程中，与你的代码linter和代码压缩器类似。</p><p>这是一个转译的简单例子。ES6增加了一个称为“默认参数值”的新特性。它看起来像是这样：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">a <span class="token operator">=</span> <span class="token number">2</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// 2</span></span>
<span class="line"><span class="token function">foo</span><span class="token punctuation">(</span> <span class="token number">42</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 42</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>简单，对吧？也很有用！但是这种新语法在前ES6引擎中是不合法的。那么转译器将会对这段代码做什么才能使它在老版本环境中运行呢？</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">	<span class="token keyword">var</span> a <span class="token operator">=</span> arguments<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!==</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> arguments<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span></span>
<span class="line">	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如你所见，它检查<code>arguments[0]</code>值是否是<code>void 0</code>（也就是<code>undefined</code>），而且如果是，就提供默认值<code>2</code>；否则，它就赋值被传递的任何东西。</p><p>除了可以现在就在老版本浏览器中使用更好的语法以外，观察转译后的代码实际上更清晰地解释了意图中的行为。</p><p>仅从ES6版本的代码看来，你可能还不理解<code>undefined</code>是唯一不能作为参数默认值的明确传递的值，但是转译后的代码使这一点清楚的多。</p><h2 id="第三章-作用域与闭包" tabindex="-1"><a class="header-anchor" href="#第三章-作用域与闭包"><span>第三章-作用域与闭包</span></a></h2><p><em>作用域与闭包</em> 从揭穿常见的误解开始：JS是“解释型语言”因此是不被编译的。不对。</p><p>JS引擎在你的代码执行的前一刻（有时是在执行期间！）编译它。所以我们首先深入了解编译器处理我们代码的方式，以此来理解它如何找到并处理变量和函数的声明。沿着这条道路，我们将见到JS变量作用域管理的特有隐喻，“提升”。</p><h1 id="你不知道的js-摘录-作用域与闭包" tabindex="-1"><a class="header-anchor" href="#你不知道的js-摘录-作用域与闭包"><span>你不知道的JS-摘录-作用域与闭包</span></a></h1><h2 id="第一章-什么是作用域" tabindex="-1"><a class="header-anchor" href="#第一章-什么是作用域"><span>第一章 什么是作用域？</span></a></h2><p>事实上，在变量中存储值和取出值的能力，给程序赋予了 <em>状态</em>。</p><p>但是在我们的程序中纳入变量，引出了我们现在将要解决的最有趣的问题：这些变量 <em>存活</em> 在哪里？换句话说，它们被存储在哪儿？而且，最重要的是，我们的程序如何在需要它们的时候找到它们？</p><p>回答这些问题需要一组明确定义的规则，它定义如何在某些位置存储变量，以及如何在稍后找到这些变量。我们称这组规则为：<em>作用域</em>。</p><h2 id="第一章-理解作用域" tabindex="-1"><a class="header-anchor" href="#第一章-理解作用域"><span>第一章-理解作用域</span></a></h2><h3 id="编译器术语" tabindex="-1"><a class="header-anchor" href="#编译器术语"><span>编译器术语</span></a></h3><p>在我们这个例子中，<em>引擎</em> 将会对变量 <code>a</code> 实施一个“LHS”查询。另一种类型的查询称为“RHS”。</p><p>这两个术语表示“Left-hand Side（左手边）”和“Right-hand Side（右手边）”</p><p>什么的……边？<strong>赋值操作的。</strong></p><p>换言之，当一个变量出现在赋值操作的左手边时，会进行 LHS 查询，当一个变量出现在赋值操作的右手边时，会进行 RHS 查询。</p><p>实际上，我们可以表述得更准确一点儿。对于我们的目的来说，一个 RHS 是难以察觉的，因为它简单地查询某个变量的值，而 LHS 查询是试着找到变量容器本身，以便它可以赋值。从这种意义上说，RHS 的含义实质上不是 <em>真正的</em> “一个赋值的右手边”，更准确地说，它只是意味着“不是左手边”。</p><p><strong>注意：</strong> LHS 和 RHS 意味着“赋值的左/右手边”未必像字面上那样意味着“ <code>=</code> 赋值操作符的左/右边”。赋值有几种其他的发生形式，所以最好在概念上将它考虑为：“赋值的目标（LHS）”和“赋值的源（RHS）”。</p><h3 id="小测验" tabindex="-1"><a class="header-anchor" href="#小测验"><span>小测验</span></a></h3><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">	<span class="token keyword">var</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span></span>
<span class="line">	<span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span> <span class="token number">2</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li><p>找到所有的 LHS 查询（有3处！）。</p></li><li><p>找到所有的 RHS 查询（有4处！）。</p></li></ol><h3 id="小测验答案" tabindex="-1"><a class="header-anchor" href="#小测验答案"><span>小测验答案</span></a></h3><ol><li><p>找出所有的 LHS 查询（有3处！）。</p><p><strong><code>c = ..</code>, <code>a = 2</code>（隐含的参数赋值）和 <code>b = ..</code></strong></p></li><li><p>找出所有的 RHS 查询（有4处！）。</p><p><strong><code>foo(2..</code>, <code>= a;</code>, <code>a + ..</code> 和 <code>.. + b</code></strong></p></li></ol><h2 id="第一章-错误" tabindex="-1"><a class="header-anchor" href="#第一章-错误"><span>第一章-错误</span></a></h2><p>为什么我们区别 LHS 和 RHS 那么重要？</p><p>因为在变量还没有被声明（在所有被查询的 <em>作用域</em> 中都没找到）的情况下，这两种类型的查询的行为不同。</p><p>考虑如下代码：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a <span class="token operator">+</span> b <span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">	b <span class="token operator">=</span> a<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token function">foo</span><span class="token punctuation">(</span> <span class="token number">2</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当 <code>b</code> 的 RHS 查询第一次发生时，它是找不到的。它被说成是一个“未声明”的变量，因为它在作用域中找不到。</p><p>如果 RHS 查询在嵌套的 <em>作用域</em> 的任何地方都找不到一个值，这会导致 <em>引擎</em> 抛出一个 <code>ReferenceError</code>。必须要注意的是这个错误的类型是 <code>ReferenceError</code>。</p><p>相比之下，如果 <em>引擎</em> 在进行一个 LHS 查询，但到达了顶层（全局 <em>作用域</em>）都没有找到它，而且如果程序没有运行在“Strict模式”[^note-strictmode]下，那么这个全局 <em>作用域</em> 将会在 <strong>全局作用域中</strong> 创建一个同名的新变量，并把它交还给 <em>引擎</em>。</p><p><em>“不，之前没有这样的东西，但是我可以帮忙给你创建一个。”</em></p><p>在 ES5 中被加入的“Strict模式”[^note-strictmode]，有许多与一般/宽松/懒惰模式不同的行为。其中之一就是不允许自动/隐含的全局变量创建。在这种情况下，将不会有全局 <em>作用域</em> 的变量交回给 LHS 查询，并且类似于 RHS 的情况, <em>引擎</em> 将抛出一个 <code>ReferenceError</code>。</p><p>现在，如果一个 RHS 查询的变量被找到了，但是你试着去做一些这个值不可能做到的事，比如将一个非函数的值作为函数运行，或者引用 <code>null</code> 或者 <code>undefined</code> 值的属性，那么 <em>引擎</em> 就会抛出一个不同种类的错误，称为 <code>TypeError</code>。</p><p><code>ReferenceError</code> 是关于 <em>作用域</em> 解析失败的，而 <code>TypeError</code> 暗示着 <em>作用域</em> 解析成功了，但是试图对这个结果进行了一个非法/不可能的动作。</p>`,71)]))}const t=s(l,[["render",c]]),d=JSON.parse('{"path":"/guide/youDontKnowJS/","title":"你不知道的JS-摘录-起步上路","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"第二章-值与类型：","slug":"第二章-值与类型","link":"#第二章-值与类型","children":[{"level":3,"title":"值的比较","slug":"值的比较","link":"#值的比较","children":[]}]},{"level":2,"title":"第二章-Strict模式","slug":"第二章-strict模式","link":"#第二章-strict模式","children":[]},{"level":2,"title":"第二章-旧的与新的","slug":"第二章-旧的与新的","link":"#第二章-旧的与新的","children":[{"level":3,"title":"转译","slug":"转译","link":"#转译","children":[]}]},{"level":2,"title":"第三章-作用域与闭包","slug":"第三章-作用域与闭包","link":"#第三章-作用域与闭包","children":[]},{"level":2,"title":"第一章 什么是作用域？","slug":"第一章-什么是作用域","link":"#第一章-什么是作用域","children":[]},{"level":2,"title":"第一章-理解作用域","slug":"第一章-理解作用域","link":"#第一章-理解作用域","children":[{"level":3,"title":"编译器术语","slug":"编译器术语","link":"#编译器术语","children":[]},{"level":3,"title":"小测验","slug":"小测验","link":"#小测验","children":[]},{"level":3,"title":"小测验答案","slug":"小测验答案","link":"#小测验答案","children":[]}]},{"level":2,"title":"第一章-错误","slug":"第一章-错误","link":"#第一章-错误","children":[]}],"git":{"updatedTime":1748771806000,"contributors":[{"name":"李锐标","username":"","email":"1415808154@qq.com","commits":1}],"changelog":[{"hash":"e40137caba1b67c60d801253108dddad5f8477da","time":1748771806000,"email":"1415808154@qq.com","author":"李锐标","message":"摘抄"}]},"filePathRelative":"guide/youDontKnowJS/README.md"}');export{t as comp,d as data};

<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.20" />
    <style>
      :root {
        --vp-c-bg: #fff;
      }

      [data-theme='dark'] {
        --vp-c-bg: #1b1b1f;
      }

      html,
      body {
        background-color: var(--vp-c-bg);
      }
    </style>
    <script>
      const useChoice = localStorage.getItem('vuepress-color-scheme')
      const systemStatus =
        'matchMedia' in window
          ? window.matchMedia('(prefers-color-scheme: dark)').matches
          : false

      if (useChoice === 'light') {
        document.documentElement.dataset.theme = 'light'
      } else if (useChoice === 'dark' || systemStatus) {
        document.documentElement.dataset.theme = 'dark'
      }
    </script>
    <link rel="icon" href="/InternshipGain/bamaofavicon.ico"><title>你不知道的JS-摘录-起步上路 | 本小八的实习收获</title><meta name="description" content="记小八的首次实习">
    <link rel="preload" href="/InternshipGain/assets/style--gozyiKw.css" as="style"><link rel="stylesheet" href="/InternshipGain/assets/style--gozyiKw.css">
    <link rel="modulepreload" href="/InternshipGain/assets/app-DSI3feuK.js"><link rel="modulepreload" href="/InternshipGain/assets/index.html-B8fZJ-y8.js">
    <link rel="prefetch" href="/InternshipGain/assets/index.html-NptTPmTI.js" as="script"><link rel="prefetch" href="/InternshipGain/assets/index.html-CIK3W7kM.js" as="script"><link rel="prefetch" href="/InternshipGain/assets/gain1.html-BryZiSwD.js" as="script"><link rel="prefetch" href="/InternshipGain/assets/gain2.html-CJtz7i0R.js" as="script"><link rel="prefetch" href="/InternshipGain/assets/gain3.html-vdiED-rm.js" as="script"><link rel="prefetch" href="/InternshipGain/assets/gain4.html-CXZWmZmk.js" as="script"><link rel="prefetch" href="/InternshipGain/assets/gain5.html-EEtaRZ1J.js" as="script"><link rel="prefetch" href="/InternshipGain/assets/gain6.html-BgQBos0G.js" as="script"><link rel="prefetch" href="/InternshipGain/assets/gain7.html-B9kG2deN.js" as="script"><link rel="prefetch" href="/InternshipGain/assets/index.html-dUFFRKQU.js" as="script"><link rel="prefetch" href="/InternshipGain/assets/use_one.html-Dc6BfMDk.js" as="script"><link rel="prefetch" href="/InternshipGain/assets/use_three.html-DvOz-RtL.js" as="script"><link rel="prefetch" href="/InternshipGain/assets/use_two.html-Bgje4mtp.js" as="script"><link rel="prefetch" href="/InternshipGain/assets/index.html-CPYh5Gxp.js" as="script"><link rel="prefetch" href="/InternshipGain/assets/404.html-CYhJTIDJ.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><div class="vp-theme-container external-link-icon" vp-container><!--[--><header class="vp-navbar" vp-navbar><div class="vp-toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a class="route-link" href="/InternshipGain/"><!----><span class="vp-site-name" aria-hidden="true">本小八的实习收获</span></a></span><div class="vp-navbar-items-wrapper" style=""><!--[--><!--]--><nav class="vp-navbar-items vp-hide-mobile" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><a class="route-link auto-link" href="/InternshipGain/" aria-label="首页"><!--[--><!--[--><!--]--><!--]-->首页<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="实习收获"><span class="title">实习收获</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="实习收获"><span class="title">实习收获</span><span class="right arrow"></span></button><ul style="display:none;" class="vp-navbar-dropdown"><!--[--><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/InternshipGain/guide/theFirstInternship/" aria-label="第一段实习"><!--[--><!--[--><!--]--><!--]-->第一段实习<!--[--><!--[--><!--]--><!--]--></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/InternshipGain/guide/theSecondInternship/" aria-label="未来的第二段实习"><!--[--><!--[--><!--]--><!--]-->未来的第二段实习<!--[--><!--[--><!--]--><!--]--></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/InternshipGain/guide/useVuepress/" aria-label="vuepress的简单使用"><!--[--><!--[--><!--]--><!--]-->vuepress的简单使用<!--[--><!--[--><!--]--><!--]--></a></li><li class="vp-navbar-dropdown-item"><a class="route-link route-link-active auto-link" href="/InternshipGain/guide/youDontKnowJS/" aria-label="你不知道的JS摘录"><!--[--><!--[--><!--]--><!--]-->你不知道的JS摘录<!--[--><!--[--><!--]--><!--]--></a></li><!--]--></ul></div></div><div class="vp-navbar-item"><a class="auto-link external-link" href="https://github.com/ogDS-X4M7" aria-label="关于作者" rel="noopener noreferrer" target="_blank"><!--[--><!--[--><!--]--><!--]-->关于作者<!--[--><!--[--><!--]--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button type="button" class="vp-toggle-color-mode-button" title="toggle color mode"><svg class="light-icon" viewbox="0 0 32 32" style=""><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg class="dark-icon" viewbox="0 0 32 32" style="display:none;"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="vp-sidebar-mask"></div><!--[--><aside class="vp-sidebar" vp-sidebar><nav class="vp-navbar-items" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><a class="route-link auto-link" href="/InternshipGain/" aria-label="首页"><!--[--><!--[--><!--]--><!--]-->首页<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="实习收获"><span class="title">实习收获</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="实习收获"><span class="title">实习收获</span><span class="right arrow"></span></button><ul style="display:none;" class="vp-navbar-dropdown"><!--[--><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/InternshipGain/guide/theFirstInternship/" aria-label="第一段实习"><!--[--><!--[--><!--]--><!--]-->第一段实习<!--[--><!--[--><!--]--><!--]--></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/InternshipGain/guide/theSecondInternship/" aria-label="未来的第二段实习"><!--[--><!--[--><!--]--><!--]-->未来的第二段实习<!--[--><!--[--><!--]--><!--]--></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/InternshipGain/guide/useVuepress/" aria-label="vuepress的简单使用"><!--[--><!--[--><!--]--><!--]-->vuepress的简单使用<!--[--><!--[--><!--]--><!--]--></a></li><li class="vp-navbar-dropdown-item"><a class="route-link route-link-active auto-link" href="/InternshipGain/guide/youDontKnowJS/" aria-label="你不知道的JS摘录"><!--[--><!--[--><!--]--><!--]-->你不知道的JS摘录<!--[--><!--[--><!--]--><!--]--></a></li><!--]--></ul></div></div><div class="vp-navbar-item"><a class="auto-link external-link" href="https://github.com/ogDS-X4M7" aria-label="关于作者" rel="noopener noreferrer" target="_blank"><!--[--><!--[--><!--]--><!--]-->关于作者<!--[--><!--[--><!--]--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="vp-sidebar-items"><!--[--><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading collapsible">第一段实习 <span class="right arrow"></span></p><ul style="display:none;" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/InternshipGain/guide/theFirstInternship/" aria-label="收获一：Vue项目中@路径别名配置"><!--[--><!--[--><!--]--><!--]-->收获一：Vue项目中@路径别名配置<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/InternshipGain/guide/theFirstInternship/gain1.html" aria-label="收获二：熟悉团队协作流程与Git"><!--[--><!--[--><!--]--><!--]-->收获二：熟悉团队协作流程与Git<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/InternshipGain/guide/theFirstInternship/gain2.html" aria-label="快速上手项目一——批量处理数据"><!--[--><!--[--><!--]--><!--]-->快速上手项目一——批量处理数据<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/InternshipGain/guide/theFirstInternship/gain3.html" aria-label="快速上手项目二——页面信息展示"><!--[--><!--[--><!--]--><!--]-->快速上手项目二——页面信息展示<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/InternshipGain/guide/theFirstInternship/gain4.html" aria-label="快速上手项目三——登录后查看内容"><!--[--><!--[--><!--]--><!--]-->快速上手项目三——登录后查看内容<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/InternshipGain/guide/theFirstInternship/gain5.html" aria-label="项目一——导出商品列表"><!--[--><!--[--><!--]--><!--]-->项目一——导出商品列表<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/InternshipGain/guide/theFirstInternship/gain6.html" aria-label="收获三——实现Excel导出工具"><!--[--><!--[--><!--]--><!--]-->收获三——实现Excel导出工具<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/InternshipGain/guide/theFirstInternship/gain7.html" aria-label="项目一——完善订单列表"><!--[--><!--[--><!--]--><!--]-->项目一——完善订单列表<!--[--><!--[--><!--]--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading collapsible">第二段实习 <span class="right arrow"></span></p><ul style="display:none;" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/InternshipGain/guide/theSecondInternship/" aria-label="暂未开始，敬请期待"><!--[--><!--[--><!--]--><!--]-->暂未开始，敬请期待<!--[--><!--[--><!--]--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading collapsible">Vuepress的简单使用 <span class="right arrow"></span></p><ul style="display:none;" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/InternshipGain/guide/useVuepress/" aria-label="快速开始一个新项目并完成部署"><!--[--><!--[--><!--]--><!--]-->快速开始一个新项目并完成部署<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/InternshipGain/guide/useVuepress/use_one.html" aria-label="代码的简单整体解读——config.js"><!--[--><!--[--><!--]--><!--]-->代码的简单整体解读——config.js<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/InternshipGain/guide/useVuepress/use_two.html" aria-label="代码的简单整体解读——首页"><!--[--><!--[--><!--]--><!--]-->代码的简单整体解读——首页<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/InternshipGain/guide/useVuepress/use_three.html" aria-label="其他文档的设计"><!--[--><!--[--><!--]--><!--]-->其他文档的设计<!--[--><!--[--><!--]--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="vp-page"><!--[--><!--]--><div vp-content><!--[--><!--]--><div><h1 id="你不知道的js-摘录-起步上路" tabindex="-1"><a class="header-anchor" href="#你不知道的js-摘录-起步上路"><span>你不知道的JS-摘录-起步上路</span></a></h1><p>顺便读一读<a href="https://github.com/getify/You-Dont-Know-JS" target="_blank" rel="noopener noreferrer">You-Dont-Know-JS</a>，把一些我觉得对我比较有启发的语句摘录下来，很多重要的内容我都没有摘抄，只是因为相对而言我对它们比较熟悉，摘抄的主要是我不熟悉甚至不知道的内容，并不是说没有摘抄的内容就不重要。</p><p>另外，在极少数我觉得需要补充的地方会写一些内容，但大多数时候原内容就已经足够简单易懂了，所以基本都是摘抄</p><p>ps:目前摘录内容较少，暂时不加入侧边栏，只从顶部栏进入查看效果。等读的差不多了再放进侧边栏</p><h2 id="第二章-值与类型" tabindex="-1"><a class="header-anchor" href="#第二章-值与类型"><span>第二章-值与类型：</span></a></h2><p>在JavaScript中只有值拥有类型；变量只是这些值的简单容器。</p><p><code>typeof null</code>是一个有趣的例子，因为当你期望它返回<code>&quot;null&quot;</code>时，它错误地返回了<code>&quot;object&quot;</code>。这是JS中一直存在的一个bug，但是看起来它永远都不会被修复了。在网络上有太多的代码依存于这个bug，因此修复它将会导致更多的bug！</p><h3 id="值的比较" tabindex="-1"><a class="header-anchor" href="#值的比较"><span>值的比较</span></a></h3><h4 id="truthy-与-falsy" tabindex="-1"><a class="header-anchor" href="#truthy-与-falsy"><span>Truthy 与 Falsy</span></a></h4><p>当一个非<code>boolean</code>值被强制转换为一个<code>boolean</code>时，它是变成<code>true</code>还是<code>false</code>。</p><p>在JavaScript中“falsy”的明确列表如下：</p><ul><li><code>&quot;&quot;</code> （空字符串）</li><li><code>0</code>, <code>-0</code>, <code>NaN</code> （非法的<code>number</code>）</li><li><code>null</code>, <code>undefined</code></li><li><code>false</code></li></ul><p>任何不在这个“falsy”列表中的值都是“truthy”。</p><h4 id="等价性" tabindex="-1"><a class="header-anchor" href="#等价性"><span>等价性</span></a></h4><p><code>==</code>和<code>===</code>之间的不同通常被描述为，<code>==</code>检查值的等价性而<code>===</code>检查值和类型两者的等价性。然而，这是不准确的。描述它们的合理方式是，<code>==</code>在允许强制转换的条件下检查值的等价性，而<code>===</code>是在不允许强制转换的条件下检查值的等价性；因此<code>===</code>常被称为“严格等价”。</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">这个部分我自己想补充一下==比较的流程的总结：</span>
<span class="line">==从上到下按照规则比较，直到能得到确切结果为止</span>
<span class="line">1.两端类型相同，比较值</span>
<span class="line">2.两端存在NaN，返回false</span>
<span class="line">3. undefined和null只有与自身比较，或者互相比较时，才会返回true</span>
<span class="line">4.两端都是原始类型，转换成数字比较</span>
<span class="line">5.一端是原始类型，一端是对象类型，把对象转换成原始类型后进入第1步</span>
<span class="line">6.两端都是对象类型直接比较引用地址是否相同</span>
<span class="line">注意直接开辟的[]、{}都会在内存中开辟一块空间，因此[]==[];{}=={}都不会相等</span>
<span class="line"></span>
<span class="line">也就是先看类型，相同直接比；</span>
<span class="line">不同的话，看看有没有NaN，有的话直接false；</span>
<span class="line">没有再看类型有没有对象，</span>
<span class="line">    有且仅有一个的话对对象进行处理成原始类型比较；</span>
<span class="line">        两个都是对象直接比引用地址是否相同；</span>
<span class="line">    没有的话转数字再比较；</span>
<span class="line">注意undefined和null的比较情况。</span>
<span class="line"></span>
<span class="line">对象如何转原始类型？下面的得不到原始值就是return {}；</span>
<span class="line">另外还有需要注意的地方，{}经过valueOf得到的还是对象，经过toString得到的是&#39;[object Object]&#39;，</span>
<span class="line">因此({})==&quot;&quot;是false，而[]==&quot;&quot;是true</span>
<span class="line">1.如果对象拥有[Symbol.toPrimitive]方法，调用该方法。</span>
<span class="line">若该方法能得到原始值，使用该原始值；</span>
<span class="line">若得不到原始值，抛出异常</span>
<span class="line">2.调用对象的value0f方法</span>
<span class="line">若该方法能得到原始值，使用该原始值；</span>
<span class="line">若得不到原始值，进入下一步</span>
<span class="line">3.调用对象的toString方法</span>
<span class="line">若该方法能得到原始值，使用该原始值;</span>
<span class="line">若得不到原始值，抛出异常</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了将这许多细节归纳为一个简单的包装，并帮助你在各种情况下判断是否使用<code>==</code>或<code>===</code>，这是我的简单规则：</p><ul><li>如果一个比较的两个值之一可能是<code>true</code>或<code>false</code>值，避免<code>==</code>而使用<code>===</code>。</li><li>如果一个比较的两个值之一可能是这些具体的值（<code>0</code>，<code>&quot;&quot;</code>，或<code>[]</code> —— 空数组），避免<code>==</code>而使用<code>===</code>。</li><li>在 <em>所有</em> 其他情况下，你使用<code>==</code>是安全的。它不仅安全，而且在许多情况下它可以简化你的代码并改善可读性。</li></ul><p>这些规则归纳出来的东西要求你严谨地考虑你的代码：什么样的值可能通过这个被比较等价性的变量。如果你可以确定这些值，那么<code>==</code>就是安全的，使用它！如果你不能确定这些值，就使用<code>===</code>。就这么简单。</p><h4 id="不等价性" tabindex="-1"><a class="header-anchor" href="#不等价性"><span>不等价性</span></a></h4><p>JavaScript<code>string</code>值也可进行不等价性比较，它使用典型的字母顺序规则（<code>&quot;bar&quot; &lt; &quot;foo&quot;</code>）。</p><p>在可能不同类型的值之间进行比较时，你可能遇到的最大的坑 —— 记住，没有“严格不等价”可用 —— 是其中一个值不能转换为合法的数字，例如：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token string">&quot;foo&quot;</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">a <span class="token operator">&lt;</span> b<span class="token punctuation">;</span>		<span class="token comment">// false</span></span>
<span class="line">a <span class="token operator">&gt;</span> b<span class="token punctuation">;</span>		<span class="token comment">// false</span></span>
<span class="line">a <span class="token operator">==</span> b<span class="token punctuation">;</span>		<span class="token comment">// false</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>等一下，这三个比较怎么可能都是<code>false</code>？因为在<code>&lt;</code>和<code>&gt;</code>的比较中，值<code>b</code>被强制转换为了“非法的数字值”，而且语言规范说<code>NaN</code>既不大于其他值，也不小于其他值。</p><h2 id="第二章-strict模式" tabindex="-1"><a class="header-anchor" href="#第二章-strict模式"><span>第二章-Strict模式</span></a></h2><p>ES5在语言中加入了一个“strict模式”，它收紧了一些特定行为的规则。</p><p>使用strict模式的一个关键不同（改善！）是，它不允许因为省略了<code>var</code>而进行隐含的自动全局变量声明：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">	<span class="token string">&quot;use strict&quot;</span><span class="token punctuation">;</span>	<span class="token comment">// 打开strict模式</span></span>
<span class="line">	a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>			<span class="token comment">// 缺少`var`，ReferenceError</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="第二章-旧的与新的" tabindex="-1"><a class="header-anchor" href="#第二章-旧的与新的"><span>第二章-旧的与新的</span></a></h2><h3 id="转译" tabindex="-1"><a class="header-anchor" href="#转译"><span>转译</span></a></h3><p>实质上，你的源代码是使用新的语法形式编写的，但是你向浏览器部署的是转译过的旧语法形式。你一般会将转译器插入到你的构建过程中，与你的代码linter和代码压缩器类似。</p><p>这是一个转译的简单例子。ES6增加了一个称为“默认参数值”的新特性。它看起来像是这样：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">a <span class="token operator">=</span> <span class="token number">2</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// 2</span></span>
<span class="line"><span class="token function">foo</span><span class="token punctuation">(</span> <span class="token number">42</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 42</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>简单，对吧？也很有用！但是这种新语法在前ES6引擎中是不合法的。那么转译器将会对这段代码做什么才能使它在老版本环境中运行呢？</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">	<span class="token keyword">var</span> a <span class="token operator">=</span> arguments<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!==</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> arguments<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span></span>
<span class="line">	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如你所见，它检查<code>arguments[0]</code>值是否是<code>void 0</code>（也就是<code>undefined</code>），而且如果是，就提供默认值<code>2</code>；否则，它就赋值被传递的任何东西。</p><p>除了可以现在就在老版本浏览器中使用更好的语法以外，观察转译后的代码实际上更清晰地解释了意图中的行为。</p><p>仅从ES6版本的代码看来，你可能还不理解<code>undefined</code>是唯一不能作为参数默认值的明确传递的值，但是转译后的代码使这一点清楚的多。</p><h2 id="第三章-作用域与闭包" tabindex="-1"><a class="header-anchor" href="#第三章-作用域与闭包"><span>第三章-作用域与闭包</span></a></h2><p><em>作用域与闭包</em> 从揭穿常见的误解开始：JS是“解释型语言”因此是不被编译的。不对。</p><p>JS引擎在你的代码执行的前一刻（有时是在执行期间！）编译它。所以我们首先深入了解编译器处理我们代码的方式，以此来理解它如何找到并处理变量和函数的声明。沿着这条道路，我们将见到JS变量作用域管理的特有隐喻，“提升”。</p><h1 id="你不知道的js-摘录-作用域与闭包" tabindex="-1"><a class="header-anchor" href="#你不知道的js-摘录-作用域与闭包"><span>你不知道的JS-摘录-作用域与闭包</span></a></h1><h2 id="第一章-什么是作用域" tabindex="-1"><a class="header-anchor" href="#第一章-什么是作用域"><span>第一章 什么是作用域？</span></a></h2><p>事实上，在变量中存储值和取出值的能力，给程序赋予了 <em>状态</em>。</p><p>但是在我们的程序中纳入变量，引出了我们现在将要解决的最有趣的问题：这些变量 <em>存活</em> 在哪里？换句话说，它们被存储在哪儿？而且，最重要的是，我们的程序如何在需要它们的时候找到它们？</p><p>回答这些问题需要一组明确定义的规则，它定义如何在某些位置存储变量，以及如何在稍后找到这些变量。我们称这组规则为：<em>作用域</em>。</p><h2 id="第一章-理解作用域" tabindex="-1"><a class="header-anchor" href="#第一章-理解作用域"><span>第一章-理解作用域</span></a></h2><h3 id="编译器术语" tabindex="-1"><a class="header-anchor" href="#编译器术语"><span>编译器术语</span></a></h3><p>在我们这个例子中，<em>引擎</em> 将会对变量 <code>a</code> 实施一个“LHS”查询。另一种类型的查询称为“RHS”。</p><p>这两个术语表示“Left-hand Side（左手边）”和“Right-hand Side（右手边）”</p><p>什么的……边？<strong>赋值操作的。</strong></p><p>换言之，当一个变量出现在赋值操作的左手边时，会进行 LHS 查询，当一个变量出现在赋值操作的右手边时，会进行 RHS 查询。</p><p>实际上，我们可以表述得更准确一点儿。对于我们的目的来说，一个 RHS 是难以察觉的，因为它简单地查询某个变量的值，而 LHS 查询是试着找到变量容器本身，以便它可以赋值。从这种意义上说，RHS 的含义实质上不是 <em>真正的</em> “一个赋值的右手边”，更准确地说，它只是意味着“不是左手边”。</p><p><strong>注意：</strong> LHS 和 RHS 意味着“赋值的左/右手边”未必像字面上那样意味着“ <code>=</code> 赋值操作符的左/右边”。赋值有几种其他的发生形式，所以最好在概念上将它考虑为：“赋值的目标（LHS）”和“赋值的源（RHS）”。</p><h3 id="小测验" tabindex="-1"><a class="header-anchor" href="#小测验"><span>小测验</span></a></h3><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">	<span class="token keyword">var</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span></span>
<span class="line">	<span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span> <span class="token number">2</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li><p>找到所有的 LHS 查询（有3处！）。</p></li><li><p>找到所有的 RHS 查询（有4处！）。</p></li></ol><h3 id="小测验答案" tabindex="-1"><a class="header-anchor" href="#小测验答案"><span>小测验答案</span></a></h3><ol><li><p>找出所有的 LHS 查询（有3处！）。</p><p><strong><code>c = ..</code>, <code>a = 2</code>（隐含的参数赋值）和 <code>b = ..</code></strong></p></li><li><p>找出所有的 RHS 查询（有4处！）。</p><p><strong><code>foo(2..</code>, <code>= a;</code>, <code>a + ..</code> 和 <code>.. + b</code></strong></p></li></ol><h2 id="第一章-错误" tabindex="-1"><a class="header-anchor" href="#第一章-错误"><span>第一章-错误</span></a></h2><p>为什么我们区别 LHS 和 RHS 那么重要？</p><p>因为在变量还没有被声明（在所有被查询的 <em>作用域</em> 中都没找到）的情况下，这两种类型的查询的行为不同。</p><p>考虑如下代码：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a <span class="token operator">+</span> b <span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">	b <span class="token operator">=</span> a<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token function">foo</span><span class="token punctuation">(</span> <span class="token number">2</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当 <code>b</code> 的 RHS 查询第一次发生时，它是找不到的。它被说成是一个“未声明”的变量，因为它在作用域中找不到。</p><p>如果 RHS 查询在嵌套的 <em>作用域</em> 的任何地方都找不到一个值，这会导致 <em>引擎</em> 抛出一个 <code>ReferenceError</code>。必须要注意的是这个错误的类型是 <code>ReferenceError</code>。</p><p>相比之下，如果 <em>引擎</em> 在进行一个 LHS 查询，但到达了顶层（全局 <em>作用域</em>）都没有找到它，而且如果程序没有运行在“Strict模式”[^note-strictmode]下，那么这个全局 <em>作用域</em> 将会在 <strong>全局作用域中</strong> 创建一个同名的新变量，并把它交还给 <em>引擎</em>。</p><p><em>“不，之前没有这样的东西，但是我可以帮忙给你创建一个。”</em></p><p>在 ES5 中被加入的“Strict模式”[^note-strictmode]，有许多与一般/宽松/懒惰模式不同的行为。其中之一就是不允许自动/隐含的全局变量创建。在这种情况下，将不会有全局 <em>作用域</em> 的变量交回给 LHS 查询，并且类似于 RHS 的情况, <em>引擎</em> 将抛出一个 <code>ReferenceError</code>。</p><p>现在，如果一个 RHS 查询的变量被找到了，但是你试着去做一些这个值不可能做到的事，比如将一个非函数的值作为函数运行，或者引用 <code>null</code> 或者 <code>undefined</code> 值的属性，那么 <em>引擎</em> 就会抛出一个不同种类的错误，称为 <code>TypeError</code>。</p><p><code>ReferenceError</code> 是关于 <em>作用域</em> 解析失败的，而 <code>TypeError</code> 暗示着 <em>作用域</em> 解析成功了，但是试图对这个结果进行了一个非法/不可能的动作。</p><h2 id="第二章-欺骗词法作用域" tabindex="-1"><a class="header-anchor" href="#第二章-欺骗词法作用域"><span>第二章-欺骗词法作用域</span></a></h2><p>如果词法作用域是由函数被声明的位置唯一定义的，而且这个位置完全是一个编写时的决定，那么怎么可能有办法在运行时“修改”（也就是，作弊欺骗）词法作用域呢？</p><p>JavaScript 有两种这样的机制。在广大的社区中它们都等同地被认为是让人皱眉头的，在你代码中使用它们是一种差劲儿的做法。但是关于它们的常见的争论经常错过了最重要的一点：<strong>欺骗词法作用域会导致更低下的性能。</strong></p><p>JavaScript 中的 <code>eval(..)</code> 函数接收一个字符串作为参数值，并将这个字符串的内容看作是好像它已经被实际编写在程序的那个位置上。换句话说，你可以用编程的方式在你编写好的代码内部生成代码，而且你可以运行这个生成的代码，就好像它在编写时就已经在那里了一样。</p><h3 id="eval" tabindex="-1"><a class="header-anchor" href="#eval"><span><code>eval</code></span></a></h3><p>考虑如下代码：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">str<span class="token punctuation">,</span> a</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">	<span class="token function">eval</span><span class="token punctuation">(</span> str <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 作弊！</span></span>
<span class="line">	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a<span class="token punctuation">,</span> b <span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token function">foo</span><span class="token punctuation">(</span> <span class="token string">&quot;var b = 3;&quot;</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1 3</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 <code>eval(..)</code> 调用的位置上，字符串 <code>&quot;var b = 3&quot;</code> 被看作是一直就存在在那里的代码。因为这个代码恰巧声明了一个新的变量 <code>b</code>，它就修改了现存的 <code>foo(..)</code> 的词法作用域。事实上，就像上面提到的那样，这个代码实际上在 <code>foo(..)</code> 内部创建了变量 <code>b</code>，它遮蔽了声明在外部（全局）作用域中的 <code>b</code>。</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">这部分我想自己总结一下</span>
<span class="line">这里eval和with在本书原文中、MDN中都看到强调了不要使用，尤其with是直接被废弃的，</span>
<span class="line">因此我甚至没有摘录关于with的使用介绍，摘录eval也只是了解一下的意思，未来不要使用</span>
<span class="line">所以这部分内容也不用仔细看，夸张一点说，总体上可以直接看 复习 部分的内容</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="性能" tabindex="-1"><a class="header-anchor" href="#性能"><span>性能</span></a></h3><p>JavaScript <em>引擎</em> 在编译阶段期行许多性能优化工作。其中的一些优化原理都归结为实质上在进行词法分析时可以静态地分析代码，并提前决定所有的变量和函数声明都在什么位置，这样在执行期间就可以少花些力气来解析标识符。</p><p>但如果 <em>引擎</em> 在代码中发现一个 <code>eval(..)</code> 或 <code>with</code>，它实质上就不得不 <em>假定</em> 自己知道的所有的标识符的位置可能是无效的，因为它不可能在词法分析时就知道你将会向<code>eval(..)</code>传递什么样的代码来修改词法作用域，或者你可能会向<code>with</code>传递的对象有什么样的内容来创建一个新的将被查询的词法作用域。</p><p>换句话说，悲观地看，如果 <code>eval(..)</code> 或 <code>with</code> 出现，那么它 <em>将</em> 做的几乎所有的优化都会变得没有意义，所以它就会简单地根本不做任何优化。</p><p>你的代码几乎肯定会趋于运行的更慢，只因为你在代码的任何地方引入了一个了 <code>eval(..)</code> 或 <code>with</code>。无论 <em>引擎</em> 将在努力限制这些悲观臆测的副作用上表现得多么聪明，<strong>都没有任何办法可以绕过这个事实：没有优化，代码就运行的更慢。</strong></p><h2 id="附录a" tabindex="-1"><a class="header-anchor" href="#附录a"><span>附录A</span></a></h2><details class="hint-container details"><summary>总结和问题发现</summary><p>其实这部分主要是希望让我们明白什么是动态作用域，但我却发现我更不了解词法作用域，动态作用域简而言之就是我之前了解的<code>this</code>，从调用位置附近层层向上查找，我以为我理解了原型链，结果只是理解了逐层向上，词法作用域没有理解，从调用位置层层向上是动态作用域。词法作用域是静态，和代码结构、编写有关。</p><p>因为之前主要了解了关于this的使用，所以我实际理解的是动态作用域，但通过本书，才了解到<code>JS</code>只有词法作用域，只是<code>this</code>和动态作用域关系更紧密；</p><p>非常关键的一句话，摘录了但在这里再次强调：<strong>词法作用域是编写时的，而动态作用域（和 <code>this</code>）是运行时的</strong>。词法作用域关心的是 <em>函数在何处被声明</em>，但是动态作用域关心的是函数 <em>从何处</em> 被调用。</p><p>因此对于这个代码示例，之所以打印出<code>2</code>，就是因为<code>foo</code>函数的词法作用域在定义时就已确定（全局作用域），与<code>foo</code>的调用位置（本例中在<code>bar</code>内调用）无关</p></details><p>正如我们在第二章中看到的，词法作用域是一组关于 <em>引擎</em> 如何查询变量和它在何处能够找到变量的规则。词法作用域的关键性质是，它是在代码编写时被定义的（假定你不使用 <code>eval()</code> 或 <code>with</code> 作弊的话）。</p><p>动态作用域看起来在暗示，有充分的理由，存在这样一种模型，它的作用域是在运行时被确定的，而不是在编写时静态地确定的。让我们通过代码来说明这样的实际情况：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">	<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span></span>
<span class="line">	<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 <code>foo()</code> 的词法作用域中指向 <code>a</code> 的 RHS 引用将被解析为全局变量 <code>a</code>，它将导致输出结果为值 <code>2</code>。</p><p>如果 JavaScript 拥有动态作用域，当 <code>foo()</code> 被执行时，<strong>理论上</strong> 下面的代码将得出 <code>3</code> 作为输出结果。</p><p>要清楚，JavaScript <strong>实际上没有动态作用域</strong>。它拥有词法作用域。就这么简单。但是 <code>this</code> 机制有些像动态作用域。</p><p>关键的差异：<strong>词法作用域是编写时的，而动态作用域（和 <code>this</code>）是运行时的</strong>。词法作用域关心的是 <em>函数在何处被声明</em>，但是动态作用域关心的是函数 <em>从何处</em> 被调用。</p><h2 id="第二章-复习" tabindex="-1"><a class="header-anchor" href="#第二章-复习"><span>第二章-复习</span></a></h2><p>在 JavaScript 中有两种机制可以“欺骗”词法作用域：<code>eval(..)</code> 和 <code>with</code>。前者可以通过对一个拥有一个或多个声明的“代码”字符串进行求值，来（在运行时）修改现存的词法作用域。后者实质上是通过将一个对象引用看作一个“作用域”，并将这个对象的属性看作作用域中的标识符，（同样，也是在运行时）创建一个全新的词法作用域。</p><p>这些机制的缺点是，它压制了 <em>引擎</em> 在作用域查询上进行编译期优化的能力，因为 <em>引擎</em> 不得不悲观地假定这样的优化是无效的。这两种特性的结果就是代码 <em>将</em> 会运行的更慢。<strong>不要使用它们。</strong></p><h2 id="第三章-隐藏于普通作用域" tabindex="-1"><a class="header-anchor" href="#第三章-隐藏于普通作用域"><span>第三章-隐藏于普通作用域</span></a></h2><p>考虑一个函数的传统方式是，你声明一个函数，并在它内部添加代码。但是相反的想法也同样强大和有用：拿你所编写的代码的任意一部分，在它周围包装一个函数声明，这实质上“隐藏”了这段代码。</p><p>其实际结果是在这段代码周围创建了一个作用域气泡，这意味着现在在这段代码中的任何声明都将绑在这个新的包装函数的作用域上，而不是前一个包含它们的作用域。换句话说，你可以通过将变量和函数围在一个函数的作用域中来“隐藏”它们。</p><p>为什么“隐藏”变量和函数是一种有用的技术？</p><p>有多种原因驱使着这种基于作用域的隐藏。它们主要是由一种称为“最低权限原则”的软件设计原则引起的[^note-leastprivilege]，有时也被称为“最低授权”或“最少曝光”。这个原则规定，在软件设计中，比如一个模块/对象的API，你应当只暴露所需要的最低限度的东西，而“隐藏”其他的一切。</p><p>这个原则可以扩展到用哪个作用域来包含变量和函数的选择。如果所有的变量和函数都在全局作用域中，它们将理所当然地对任何嵌套的作用域来说都是可访问的。但这回违背“最少……”原则，因为你（很可能）暴露了许多你本应当保持为私有的变量和函数，而这些代码的恰当用法是不鼓励访问这些变量/函数的。 例如：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line"><span class="token keyword">function</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">	b <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token function">doSomethingElse</span><span class="token punctuation">(</span> a <span class="token operator">*</span> <span class="token number">2</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> b <span class="token operator">*</span> <span class="token number">3</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">function</span> <span class="token function">doSomethingElse</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">	<span class="token keyword">return</span> a <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">var</span> b<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token function">doSomething</span><span class="token punctuation">(</span> <span class="token number">2</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 15</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个代码段中，变量 <code>b</code> 和函数 <code>doSomethingElse(..)</code> 很可能是 <code>doSomething(..)</code> 如何工作的“私有”细节。允许外围的作用域“访问” <code>b</code> 和 <code>doSomethingElse(..)</code> 不仅没必要而且可能是“危险的”，因为它们可能会以种种意外的方式，有意或无意地被使用，而这也许违背了 <code>doSomething(..)</code> 假设的前提条件。</p><p>一个更“恰当”的设计是讲这些私有细节隐藏在<code>doSomething(..)</code>的作用域内部，比如：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line"><span class="token keyword">function</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">	<span class="token keyword">function</span> <span class="token function">doSomethingElse</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">		<span class="token keyword">return</span> a <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line">	<span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">	<span class="token keyword">var</span> b<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">	b <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token function">doSomethingElse</span><span class="token punctuation">(</span> a <span class="token operator">*</span> <span class="token number">2</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> b <span class="token operator">*</span> <span class="token number">3</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token function">doSomething</span><span class="token punctuation">(</span> <span class="token number">2</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 15</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在，<code>b</code> 和 <code>doSomethingElse(..)</code> 对任何外界影响都是不可访问的，而是仅仅由 <code>doSomething(..)</code> 控制。它的功能和最终结果不受影响，但是这种设计将私有细节保持为私有的，这通常被认为是好的软件。</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">这部分内容我也做一下总结，隐藏简单来说就是用函数包起来，外面不能直接使用</span>
<span class="line">尤其是函数包函数，函数A内函数B只用来处理函数A内的业务，可以说成为了函数A私有的内容</span>
<span class="line">当然，具体实现还要看具体需求，比如B是否需要多次复用？是否只在A内复用？</span>
<span class="line">如果B需要多次复用，才有封装的需求；只在A内复用，才能被A私有。</span>
<span class="line">所以感觉局限性比较大，但作为好的软件设计，思路还是要了解并记住的</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="避免冲突" tabindex="-1"><a class="header-anchor" href="#避免冲突"><span>避免冲突</span></a></h3><p>将变量和函数“隐藏”在一个作用域内部的另一个好处是，避免两个同名但用处不同的标识符之间发生无意的冲突。冲突经常导致值被意外地覆盖。</p><p>例如：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">	<span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">		i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">// 在外围的for循环的作用域中改变`i`</span></span>
<span class="line">		console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a <span class="token operator">+</span> i <span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">	<span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">		<span class="token function">bar</span><span class="token punctuation">(</span> i <span class="token operator">*</span> <span class="token number">2</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 噢，无限循环！</span></span>
<span class="line">	<span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>bar(..)</code> 内部的赋值 <code>i = 3</code> 意外地覆盖了在 <code>foo(..)</code> 的for循环中声明的 <code>i</code>。在这个例子中，这将导致一个无限循环，因为 <code>i</code> 被设定为固定的值 <code>3</code>，而它将永远 <code>&lt; 10</code>。</p><p><code>bar(..)</code> 内部的赋值需要声明一个本地变量来使用，不论选用什么样的标识符名称。<code>var i = 3;</code> 将修复这个问题（并将为 <code>i</code> 创建一个前面提到的“遮蔽变量”声明）。一个 <em>另外的</em> 选项，不是代替的选项，是完全选择另外一个标识符名称，比如 <code>var j = 3;</code>。但是你的软件设计也许会自然而然地使用相同的标识符名称，所以在这种情况下利用作用域来“隐藏”你的内部声明是你最好/唯一的选择。</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">就是说要么用var i = 3；这样作用域就只在bar()中——局部变量，不影响到foo()里的i；</span>
<span class="line">要么干脆用j；不同名字变量肯定不覆盖</span>
<span class="line">跟这里讲的隐藏有关系的就是bar里面的i，只要用var i就实现了通过外部包函数(bar)来隐藏的目的</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="全局-名称空间" tabindex="-1"><a class="header-anchor" href="#全局-名称空间"><span>全局“名称空间”</span></a></h4><p>变量冲突（很可能）发生的一个特别强有力的例子是在全局作用域中。当多个库被加载到你的程序中时，如果它们没有适当地隐藏它们的内部/私有函数和变量，那么它们可以十分容易地互相冲突。</p><p>这样的库通常会在全局作用域中使用一个足够独特的名称来创建一个单独的变量声明，它经常是一个对象。然后这个对象被用作这个库的一个“名称空间”，所有要明确暴露出来的功能都被作为属性挂在这个对象（名称空间）上，而不是将它们自身作为顶层词法作用域的标识符。</p><p>例如：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line"><span class="token keyword">var</span> MyReallyCoolLibrary <span class="token operator">=</span> <span class="token punctuation">{</span></span>
<span class="line">	<span class="token literal-property property">awesome</span><span class="token operator">:</span> <span class="token string">&quot;stuff&quot;</span><span class="token punctuation">,</span></span>
<span class="line">	<span class="token function-variable function">doSomething</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">		<span class="token comment">// ...</span></span>
<span class="line">	<span class="token punctuation">}</span><span class="token punctuation">,</span></span>
<span class="line">	<span class="token function-variable function">doAnotherThing</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">		<span class="token comment">// ...</span></span>
<span class="line">	<span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="模块管理" tabindex="-1"><a class="header-anchor" href="#模块管理"><span>模块管理</span></a></h4><p>另一种回避冲突的选择是通过任意一种依赖管理器，使用更加现代的“模块”方式。使用这些工具，没有库可以向全局作用域添加任何标识符，取而代之的是使用依赖管理器的各种机制，要求库的标识符被明确地导入到另一个指定的作用域中。</p><p>应该可以看到，这些工具并不拥有可以豁免于词法作用域规则的“魔法”功能。它们简单地使用这里讲解的作用域规则，来强制标识符不会被注入任何共享的作用域，而是保持在私有的，不易冲突的作用域中，这防止了任何意外的作用域冲突。</p><h2 id="第三章-函数作为作用域" tabindex="-1"><a class="header-anchor" href="#第三章-函数作为作用域"><span>第三章-函数作为作用域</span></a></h2><p>我们已经看到，我们可以拿来一段代码并在它周围包装一个函数，而这实质上对外部作用域“隐藏”了这个函数内部作用域包含的任何变量或函数声明。</p><p>例如：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// &lt;-- 插入这个</span></span>
<span class="line"></span>
<span class="line">	<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span></span>
<span class="line">	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span></span>
<span class="line"></span>
<span class="line"><span class="token punctuation">}</span> <span class="token comment">// &lt;-- 和这个</span></span>
<span class="line"><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &lt;-- 还有这个</span></span>
<span class="line"></span>
<span class="line">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>虽然这种技术“可以工作”，但它不一定非常理想。它引入了几个问题。首先是我们不得不声明一个命名函数 <code>foo()</code>，这意味着这个标识符名称 <code>foo</code> 本身就“污染”了外围作用域（在这个例子中是全局）。我们要不得不通过名称（<code>foo()</code>）明确地调用这个函数来使被包装的代码真正运行。</p><p>如果这个函数不需要名称（或者，这个名称不污染外围作用域），而且如果这个函数能自动地被执行就更理想了。</p><p>幸运的是，JavaScript 给这两个问题提供了一个解决方法。</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// &lt;-- 插入这个</span></span>
<span class="line"></span>
<span class="line">	<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span></span>
<span class="line">	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span></span>
<span class="line"></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &lt;-- 和这个</span></span>
<span class="line"></span>
<span class="line">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>让我们分析一下这里发生了什么。</p><p>首先注意，与仅仅是 <code>function...</code> 相对，这个包装函数语句以 <code>(function...</code> 开头。虽然这看起来像是一个微小的细节，但实际上这是一个重大改变。与将这个函数视为一个标准的声明不同的是，这个函数被视为一个函数表达式。</p><p><strong>注意：</strong> 区分声明与表达式的最简单的方法是，这个语句中（不仅仅是一行，而是一个独立的语句）“function”一词的位置。如果“function”是这个语句中的第一个东西，那么它就是一个函数声明。否则，它就是一个函数表达式。</p><p>这里我们可以观察到一个函数声明和一个函数表达式之间的关键不同是，它的名称作为一个标识符被绑定在何处。</p><p>比较这前两个代码段。在第一个代码段中，名称 <code>foo</code> 被绑定在外围作用域中，我们用 <code>foo()</code> 直接调用它。在第二个代码段中，名称 <code>foo</code> 没有被绑定在外围作用域中，而是被绑定在它自己的函数内部。</p><p>换句话说，<code>(function foo(){ .. })</code> 作为一个表达式意味着标识符 <code>foo</code> 仅能在 <code>..</code> 代表的作用域中被找到，而不是在外部作用域中。将名称 <code>foo</code> 隐藏在它自己内部意味着它不会没必要地污染外围作用域。</p><details class="hint-container details"><summary>提醒自己一下，上面这部分要仔细看</summary><p>对我来说是很不错的讲解，因为关于立即执行函数的内容都是之前遇到临时学的，并不扎实，现在可以更好地理解了</p><p>虽然原文下面有更详细的关于立即执行函数的讲解，但上面这部分内容对我来说就足够了，下面主要就是一些变种和命名匿名的选择，并不重要，摘抄太多反而啰嗦</p></details><h2 id="第三章-块级作为作用域" tabindex="-1"><a class="header-anchor" href="#第三章-块级作为作用域"><span>第三章-块级作为作用域</span></a></h2><p>这就是有关块级作用域的一切。尽可能靠近地，尽可能局部地，在变量将被使用的位置声明它。另一个例子是：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line"><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">if</span> <span class="token punctuation">(</span>foo<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">	<span class="token keyword">var</span> bar <span class="token operator">=</span> foo <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span></span>
<span class="line">	bar <span class="token operator">=</span> <span class="token function">something</span><span class="token punctuation">(</span> bar <span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> bar <span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们仅在 if 语句的上下文环境中使用变量 <code>bar</code>，所以我们将它声明在 if 块级的内部是有些道理的。然而，当使用 <code>var</code> 时，我们在何处声明变量是无关紧要的，因为它们将总是属于外围作用域。这个代码段实质上为了代码风格的原因“假冒”了块级作用域，并依赖于我们要管好自己，不要在这个作用域的其他地方意外地使用 <code>bar</code>。</p><details class="hint-container details"><summary>总结与注意</summary><p>说了一大堆，这里的<code>bar</code>仍然是全局变量，<code>if</code>外仍然可以获取<code>bar</code>，原因很简单，想要块级作用域得用<code>let</code>、<code>const</code>，如果<code>var</code>这样能实现块级作用域，那<code>ES6</code>还折腾那么多干嘛？原文的意思是这只是代码风格，依赖于我们自己管理，没有实际块级作用域效果，这里原文写的太啰嗦反而显得容易误导，道理就是我写的这么简单。</p></details><h3 id="try-catch" tabindex="-1"><a class="header-anchor" href="#try-catch"><span><code>try/catch</code></span></a></h3><p>一个鲜为人知的事实是，JavaScript 在 ES3 中明确指出在 <code>try/catch</code> 的 <code>catch</code> 子句中声明的变量，是属于 <code>catch</code> 块级的块级作用域的。</p><p>例如：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line"><span class="token keyword">try</span> <span class="token punctuation">{</span></span>
<span class="line">	<span class="token keyword">undefined</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//用非法的操作强制产生一个异常！</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"><span class="token keyword">catch</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> err <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 好用！</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> err <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ReferenceError: `err` not found</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如你所见，<code>err</code> 仅存在于 <code>catch</code> 子句中，并且在你试着从其他地方引用它时抛出一个错误。</p><p><strong>注意：</strong> 虽然这种行为已经被明确规定，而且对于几乎所有的标准JS环境（也许除了老IE）来说都是成立的，但是如果你在同一个作用域中有两个或多个 <code>catch</code> 子句，而它们又各自用相同的标识符名称声明了它们表示错误的变量时，许多 linter 依然会报警。实际上这不是重定义，因为这些变量都安全地位于块级作用域中，但是 linter 看起来依然会恼人地抱怨这个事实。</p><p>为了避免这些不必要的警告，一些开发者将他们的 <code>catch</code> 变量命名为 <code>err1</code>，<code>err2</code>，等等。另一些开发者干脆关闭 linter 对重复变量名的检查。</p><p><code>catch</code> 的块级作用域性质看起来像是一个没用的，只有学院派意义的事实，但是参看附录B来了解更多它如何有用的信息。</p><h3 id="let" tabindex="-1"><a class="header-anchor" href="#let"><span><code>let</code></span></a></h3><h4 id="垃圾回收" tabindex="-1"><a class="header-anchor" href="#垃圾回收"><span>垃圾回收</span></a></h4><p>块级作用域的另一个有用之处是关于闭包和释放内存的垃圾回收。我们将简单地在这里展示一下，但是闭包机制将在第五章中详细讲解。</p><p>考虑这段代码：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line"><span class="token keyword">function</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">	<span class="token comment">// 做些有趣的事</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">var</span> someReallyBigData <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token function">process</span><span class="token punctuation">(</span> someReallyBigData <span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">var</span> btn <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span> <span class="token string">&quot;my_button&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">btn<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span> <span class="token string">&quot;click&quot;</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token function">click</span><span class="token punctuation">(</span><span class="token parameter">evt</span><span class="token punctuation">)</span><span class="token punctuation">{</span></span>
<span class="line">	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;button clicked&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">/*capturingPhase=*/</span><span class="token boolean">false</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>点击事件的处理器回调函数 <code>click</code> 根本不 <em>需要</em> <code>someReallyBigData</code> 变量。这意味着从理论上讲，在 <code>process(..)</code> 运行之后，这个消耗巨大内存的数据结构可以被作为垃圾回收。然而，JS引擎很可能（虽然这要看具体实现）仍会将这个结构保持一段时间，因为<code>click</code>函数在整个作用域上拥有一个闭包。</p><p>块级作用域可以解决这个问题，使引擎清楚地知道它不必再保持 <code>someReallyBigData</code> 了：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line"><span class="token keyword">function</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">	<span class="token comment">// 做些有趣的事</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// 运行过后，任何定义在这个块中的东西都可以消失了</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">	<span class="token keyword">let</span> someReallyBigData <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">	<span class="token function">process</span><span class="token punctuation">(</span> someReallyBigData <span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">var</span> btn <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span> <span class="token string">&quot;my_button&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">btn<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span> <span class="token string">&quot;click&quot;</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token function">click</span><span class="token punctuation">(</span><span class="token parameter">evt</span><span class="token punctuation">)</span><span class="token punctuation">{</span></span>
<span class="line">	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;button clicked&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">/*capturingPhase=*/</span><span class="token boolean">false</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>声明可以将变量绑定在本地的明确的块级是一种强大的工具，你可以把它加入你的工具箱。</p><details class="hint-container details"><summary>总结</summary><p>注意区分这里的<code>{}</code>达到的效果和<a href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%9D%97%E7%BA%A7%E4%BD%9C%E4%B8%BA%E4%BD%9C%E7%94%A8%E5%9F%9F">之前</a>在<code>if</code>内声明变量的那种没有实际作用的效果，就知道关键在于<code>let</code>了；</p><p>另外，正是有这里<code>{}</code>的代码块划分的作用，所以之前写<code>{}=={}</code>会直接报错，因为会被理解成代码块，需要写成<code>({})==...</code></p></details><h2 id="第四章-函数优先" tabindex="-1"><a class="header-anchor" href="#第四章-函数优先"><span>第四章-函数优先</span></a></h2><details class="hint-container details"><summary>提示修正</summary><p>这个章节讲的是提升，有变量提升、函数提升，我比较熟悉，看过一遍感觉没什么需要摘抄的，不过遇到一个比较疑惑的点，经过验证我的想法是对的，而书中也提到未来会修改，看来对于当时而言的“未来的修改”在我读这本书的时候已经到来了</p><p>对于我阅读并发现异常的时候，下面的代码运行时已经会报错：<code>Uncaught TypeError: foo is not a function</code>，并不会给出注释的“b”</p><p>原因很简单，如果这个<code>function</code>的声明会提升，那<code>if(a)</code>也会提前执行，这显然违反常理，这部分代码就应该自上而下正常执行，按序<code>a</code>被赋值，然后进入判定语句，最后根据<code>a</code>给出函数声明；那么最开始调用的时候<code>foo</code>当然还没有声明，一定会报错。</p><p>下面是原文</p></details><p>在同一个作用域内的重复定义是一个十分差劲儿的主意，而且经常会导致令人困惑的结果。</p><p>在普通的块级内部出现的函数声明一般会被提升至外围的作用域，而不是像这段代码暗示的那样有条件地被定义：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line"><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;b&quot;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">   <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token string">&quot;a&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"><span class="token keyword">else</span> <span class="token punctuation">{</span></span>
<span class="line">   <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token string">&quot;b&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然而，重要的是要注意这种行为是不可靠的，而且是未来版本的 JavaScript 将要改变的对象，所以避免在块级中声明函数可能是最好的做法。（再次提醒，这里有误，要看我写的修正！）</p><h2 id="第五章-事实真相" tabindex="-1"><a class="header-anchor" href="#第五章-事实真相"><span>第五章-事实真相</span></a></h2><p>为了理解和识别闭包，这里有一个你需要知道的简单粗暴的定义：</p><blockquote><p>闭包就是函数能够记住并访问它的词法作用域，即使当这个函数在它的词法作用域之外执行时。</p></blockquote><p>让我们跳进代码来说明这个定义：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">	<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">	<span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">		console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span></span>
<span class="line">	<span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">	<span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>根据我们对嵌套作用域的讨论，这段代码应当看起来很熟悉。由于词法作用域查询规则（在这个例子中，是一个 RHS 引用查询），函数 <code>bar()</code> 可以 <em>访问</em> 外围作用域的变量 <code>a</code>。</p><p>这是“闭包”吗？</p><p>好吧，从技术上讲…… <em>也许是</em>。但是根据我们上面的“你需要知道”的定义…… <em>不确切</em>。我认为解释 <code>bar()</code> 引用 <code>a</code> 的最准确的方式是根据词法作用域查询规则，但是那些规则 <em>仅仅</em> 是闭包的（一个很重要的！）<strong>一部分</strong>。</p><p>从纯粹的学院派角度讲，上面的代码段被认为是函数 <code>bar()</code> 在函数 <code>foo()</code> 的作用域上有一个 <em>闭包</em>（而且实际上，它甚至对其他的作用域也可以访问，比如这个例子中的全局作用域）。换一种略有不同的说法是，<code>bar()</code> 闭住了 <code>foo()</code> 的作用域。为什么？因为 <code>bar()</code> 嵌套地出现在 <code>foo()</code> 内部。就这么简单。</p><p>但是，这样一来闭包的定义就是不能直接 <em>观察到</em> 的了，我们也不能看到闭包在这个代码段中 <em>被行使</em>。我们清楚地看到词法作用域，但是闭包仍然像代码后面谜一般的模糊阴影。</p><details class="hint-container details"><summary>简化</summary><p>上面这部分啰嗦的内容有些多余，主要是和下面的代码对比，上面的代码也是闭包，但是效果不够明显，下面的效果比较明显。这段话就是我说的这个意思</p><p>重点在于理解上面的定义</p></details><p>让我们考虑这段将闭包完全带到聚光灯下的代码：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">	<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">	<span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">		console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">	<span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">	<span class="token keyword">return</span> bar<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">var</span> baz <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token function">baz</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2 -- 哇噢，看到闭包了，伙计。</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>函数 <code>bar()</code> 对于 <code>foo()</code> 内的作用域拥有词法作用域访问权。但是之后，我们拿起 <code>bar()</code>，这个函数本身，将它像 <em>值</em> 一样传递。在这个例子中，我们 <code>return</code> <code>bar</code> 引用的函数对象本身。</p><p>在执行 <code>foo()</code> 之后，我们将它返回的值（我们的内部 <code>bar()</code> 函数）赋予一个称为 <code>baz</code> 的变量，然后我们实际地调用 <code>baz()</code>，这将理所当然地调用我们内部的函数 <code>bar()</code>，只不过是通过一个不同的标识符引用。</p><p><code>bar()</code> 被执行了，必然的。但是在这个例子中，它是在它被声明的词法作用域 <em>外部</em> 被执行的。</p><p><code>foo()</code> 被执行之后，一般说来我们会期望 <code>foo()</code> 的整个内部作用域都将消失，因为我们知道 <em>引擎</em> 启用了 <em>垃圾回收器</em> 在内存不再被使用时来回收它们。因为很显然 <code>foo()</code> 的内容不再被使用了，所以看起来它们很自然地应该被认为是 <em>消失了</em>。</p><p>但是闭包的“魔法”不会让这发生。内部的作用域实际上 <em>依然</em> “在使用”，因此将不会消失。谁在使用它？<strong>函数 <code>bar()</code> 本身。</strong></p><p>有赖于它被声明的位置，<code>bar()</code> 拥有一个词法作用域闭包覆盖着 <code>foo()</code> 的内部作用域，闭包为了能使 <code>bar()</code> 在以后任意的时刻可以引用这个作用域而保持它的存在。</p><p><strong><code>bar()</code> 依然拥有对那个作用域的引用，而这个引用称为闭包。</strong></p><p>所以，在几微秒之后，当变量 <code>baz</code> 被调用时（调用我们最开始标记为 <code>bar</code> 的内部函数），它理所应当地对编写时的词法作用域拥有 <em>访问</em> 权，所以它可以如我们所愿地访问变量 <code>a</code>。</p><p>这个函数在它被编写时的词法作用域之外被调用。<strong>闭包</strong> 使这个函数可以继续访问它在编写时被定义的词法作用域。</p><p>当然，函数可以被作为值传递，而且实际上在其他位置被调用的所有各种方式，都是观察/行使闭包的例子。</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">	<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">	<span class="token keyword">function</span> <span class="token function">baz</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">		console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span></span>
<span class="line">	<span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">	<span class="token function">bar</span><span class="token punctuation">(</span> baz <span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">	<span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 看妈妈，我看到闭包了！</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们将内部函数 <code>baz</code> 传递给 <code>bar</code>，并调用这个内部函数（现在被标记为 <code>fn</code>），当我们这么做时，它覆盖在 <code>foo()</code> 内部作用域的闭包就可以通过 <code>a</code> 的访问观察到。</p><p>这样的函数传递也可以是间接的。</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line"><span class="token keyword">var</span> fn<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">	<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">	<span class="token keyword">function</span> <span class="token function">baz</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">		console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">	<span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">	fn <span class="token operator">=</span> baz<span class="token punctuation">;</span> <span class="token comment">// 将`baz`赋值给一个全局变量</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">	<span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 看妈妈，我看到闭包了！</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>无论我们使用什么方法将内部函数 <em>传送</em> 到它的词法作用域之外，它都将维护一个指向它最开始被声明时的作用域的引用，而且无论我们什么时候执行它，这个闭包就会被行使。</p><h2 id="第五章-现在我能看到了" tabindex="-1"><a class="header-anchor" href="#第五章-现在我能看到了"><span>第五章-现在我能看到了</span></a></h2><p>前面的代码段有些学术化，而且是人工构建来说明 <em>闭包的使用</em> 的。但我保证过给你的东西不止是一个新的酷玩具。我保证过闭包是在你的现存代码中无处不在的东西。现在让我们 <em>看看</em> 真相。</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line"><span class="token keyword">function</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token parameter">message</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line"></span>
<span class="line">	<span class="token function">setTimeout</span><span class="token punctuation">(</span> <span class="token keyword">function</span> <span class="token function">timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span></span>
<span class="line">		console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> message <span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">	<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token function">wait</span><span class="token punctuation">(</span> <span class="token string">&quot;Hello, closure!&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们拿来一个内部函数（名为 <code>timer</code>）将它传递给 <code>setTimeout(..)</code>。但是 <code>timer</code> 拥有覆盖 <code>wait(..)</code> 的作用域的闭包，实际上保持并使用着对变量 <code>message</code> 的引用。</p><p>在我们执行 <code>wait(..)</code> 一千毫秒之后，要不是内部函数 <code>timer</code> 依然拥有覆盖着 <code>wait()</code> 内部作用域的闭包，它早就会消失了。</p><p>在 <em>引擎</em> 的内脏深处，内建的工具 <code>setTimeout(..)</code> 拥有一些参数的引用，可能称为 <code>fn</code> 或者 <code>func</code> 或者其他诸如此类的东西。<em>引擎</em> 去调用这个函数，它调用我们的内部 <code>timer</code> 函数，而词法作用域依然完好无损。</p><details class="hint-container details"><summary>解析</summary><p>这部分内容的描述看起来有点抽象，我看的时候有点迷糊，主要还是没有谨记、紧扣闭包的定义：</p><blockquote><p>闭包就是函数能够记住并访问它的词法作用域，即使当这个函数在它的词法作用域之外执行时。</p></blockquote><p>另外，我还需要记得词法作用域的关键性质是，它是在代码编写时被定义的，静态的，与代码编写结构有关的！</p><p>因此这里很明显：内部函数 <code>timer</code> 依然拥有覆盖着 <code>wait()</code> 内部作用域的闭包，也就是<code>timer</code>函数是 “捕获” 了<code>wait</code>函数的作用域，它引用了外部变量<code>message</code>，因此记住了词法作用域在<code>wait()</code> 内部，就是这么个意思。</p></details><p>实质上 <em>无论何时何地</em> 只要你将函数作为头等的值看待并将它们传来传去的话，你就可能看到这些函数行使闭包。计时器、事件处理器、Ajax请求、跨窗口消息、web worker、或者任何其他的异步（或同步！）任务，当你传入一个 <em>回调函数</em>，你就在它周围悬挂了一些闭包！</p><details class="hint-container details"><summary>解析</summary><p>这里我注意到原文写的是一些闭包，在这里解析一下为什么会说一些闭包：</p><p><strong>闭包数量的决定因素如下：</strong></p><p><strong>每次函数定义都会创建新闭包：</strong> 无论在循环中、事件监听中，还是作为返回值，函数每定义一次就会创建一个新的闭包实例。</p><p><strong>闭包捕获的是变量引用：</strong> 闭包捕获的变量是否独立，取决于变量的作用域（如 let 与 var 的区别）。</p><p><strong>异步任务中的闭包更隐蔽：</strong> 异步回调（如定时器、事件监听）的闭包会在未来执行，容易忽略其捕获的变量状态。</p><p>闭包的数量与<strong>函数定义的次数</strong>直接相关，而不是调用次数。一定记住是<strong>定义次数</strong></p><p><strong>示例：多次调用同一函数生成多个闭包</strong></p><p><strong>注意：</strong> 如果改成<code>var</code>，也是两个闭包，因为每次调用都会开辟一个空间，不要误会和循环一样了。</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">function createCounter() {</span>
<span class="line">  let count = 0;</span>
<span class="line">  return function() {</span>
<span class="line">    return ++count; // 闭包捕获 count</span>
<span class="line">  };</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line">const counterA = createCounter(); // 闭包A</span>
<span class="line">const counterB = createCounter(); // 闭包B</span>
<span class="line"></span>
<span class="line">console.log(counterA()); // 1</span>
<span class="line">console.log(counterA()); // 2</span>
<span class="line">console.log(counterB()); // 1（闭包B的 count 独立）</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再来一些典型场景：</p><p><strong>循环中的闭包（最容易产生多个闭包）</strong></p><p>如果这里改成<code>var i</code>就会输出三个<code>i</code>了，因为注意到这里<code>timer</code>放进三个箭头函数，使用<code>var</code>的话指向一个作用域，后续箭头函数被调用，访问作用域取到的就是3</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">function createTimers() {</span>
<span class="line">  const timers = [];</span>
<span class="line">  for (let i = 0; i &lt; 3; i++) {</span>
<span class="line">    timers.push(() =&gt; {</span>
<span class="line">      console.log(i); // 闭包捕获了每次循环的 i</span>
<span class="line">    });</span>
<span class="line">  }</span>
<span class="line">  return timers;</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line">const [timer1, timer2, timer3] = createTimers();</span>
<span class="line">timer1(); // 0</span>
<span class="line">timer2(); // 1</span>
<span class="line">timer3(); // 2</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>事件监听器中的多个闭包</strong></p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">function setupButtons() {</span>
<span class="line">  const buttons = document.querySelectorAll(&quot;button&quot;);</span>
<span class="line">  </span>
<span class="line">  buttons.forEach((button, index) =&gt; {</span>
<span class="line">    button.addEventListener(&quot;click&quot;, () =&gt; {</span>
<span class="line">      console.log(`Button ${index} clicked`); // 闭包捕获 index</span>
<span class="line">    });</span>
<span class="line">  });</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line">setupButtons(); // 假设页面有3个按钮</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h1 id="注意" tabindex="-1"><a class="header-anchor" href="#注意"><span>注意</span></a></h1><p>后续的话把自己的总结等部分内容改用折叠演示结果写，不要用代码模式，不然看起来不舒服而且写的时候总是要顾及每行字体的长度，太麻烦</p></div><!--[--><!--]--></div><footer class="vp-page-meta"><!----><div class="vp-meta-item git-info"><div class="vp-meta-item last-updated"><span class="meta-item-label">最近更新：: </span><time class="meta-item-info" datetime="2025-06-03T03:22:15.000Z" data-allow-mismatch>2025/6/3 03:22</time></div><!----></div></footer><!----><!--[--><!--]--></main><!--]--></div><!--[--><!----><!--]--><!--]--></div>
    <script type="module" src="/InternshipGain/assets/app-DSI3feuK.js" defer></script>
  </body>
</html>

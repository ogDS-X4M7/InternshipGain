# 实习杂记
来到大厂实习后，学到了很多东西，但是规范和约束也非常多，所以可能不能像之前那样详细记录了，不过有些知识点的收获还是可以写一下：


## 项目设计——防耦合
为了项目的长期顺利运行，设计编写代码时需要考虑解耦：

简单来说，每个模块的功能都要尽可能做到可拆分，与无关的代码尽量减少联系，比如实现一个a功能，通常是编写一个组件，或者复用组件，为了实现功能可能会有很多的判断细节，可能判断的条件在在调用这个组件的父组件中，但是不应该把判断逻辑交给父组件，而是尽量都放到组件内实现，这就是解耦，其实也是为了尽可能地实现代码的可复用性，毕竟如果这个组件的a功能需要依托其父组件进行大量的判断，那么其他代码想要复用的话又得重复这部分判断，显然不合适。


## 项目设计——方案评审与用户体验
来到这边，自己也写过一些技术方案，参与了技术评审，其中遇到一个比较细节的点，大概就是a功能是判别用户点击或滑动来实现一个弹窗提醒，这是产品需求。

我当时看到的时候觉得没有什么问题，但是当自己实现后去自测，就会发现不合理的点，比如点击退出，也要弹窗，这是很不合理的。

其实如果从用户角度出发，会更快更容易意识到这个需求的不合理性，点击是一个很基础很广泛的交互逻辑，用户在页面上想要进行任何操作都要点击，但是如果点击后的第一个反应变成强制弹窗，很可能和用户的预期不符，造成用户体验不良。

最后需求改为了用户浏览x秒后弹窗，实现起来更简单，但用户体验更良好是最重要的。

## 居中样式的副作用
居中样式是非常常见的面试题，其中`left:50%;transform: translateX(-50%)`也是其中最常见的写法之一。但是我从来没有想过，这样的写法会压缩盒子的最大宽度；

其实原理和逻辑我都懂，这也是我在遇到这个有些诡异的情况的时候最后能够想明白的原因。`transform`实现元素移动可以说是最高效的，因为`transform`既不会影响布局，也不会影响绘制指令。他是直接在画出画面的阶段完成。把内容渲染到页面上一般是要分成8个步骤，它包括`HTML`的解析。样式的计算、布局、分层、生成绘制指令、分块、光栅化和画。因此一些页面的元素进行移动旋转等操作的时候，`transform`是一种非常好的实现方式，因此也是非常常用的实现方式。但恰恰是它的这个特性导致了盒子的样式经历了left:50%之后就可以渲染，然后得到了一个最多只有屏幕宽度一半的盒子，并且通过`transform`移动居中之后盒子的宽度也是不变的，因为正如刚刚原理所说，它是指影响最后的一个步骤，也就是画的步骤，他并不干扰样式的计算，不干扰`dom`的布局。

这些原理都很简单，我也都知道。但是从来没有考虑过他会造成这样的一个结果。解决它的办法也并不复杂，最后我是通过强制不换行`whitespace:nowrap`来保证我设计的内容不会因为盒子的长度只有屏幕的一半不够长而出现换行的非预期情况。

## 可能的内存泄漏——逻辑的必然与锁的解决
在实现第二个弹窗功能时，由于弹窗是组件复用的，所以对于不同情况下展现的不同弹窗内容是由对应的信号控制。这些信号通常就是标志着某种特定情景的发生，因为只有在某种特定情景下，弹窗会显示特定的样式内容。而对于所谓的某种特定情形是通过父组件调用组件并传递参数`A`给子组件得到的。由于之前的代码逻辑在一些特定情形下组件会被提前挂载，所以对于所需的这个参数`A`，需要监听来保证能够获取正确的内容。

这样的设计跟之前是相同的，不会有什么问题。但是第二个需求提出了对特定情况进行处理，而解决它的方式是组件通信。组件通信的方式有很多，这个地方采取的是事件总线，这就意味着需要使用`buson`，而为了保证是事件总线能够监听到另一个组件发送的通信信息`B`，通常在这个组件挂载的时候，我们会`buson`来进行监听，这个操作应该可以说是刻不容缓的，因为如果`buson`的监听稍微晚挂载上去，那么很有可能另一个组件发送的通信信息`B`不能够及时被监听到，所以说这个监听会被放在逻辑的最外层实现。

上面已经讲完了需求的情景和面临的情况，可以看到对于弹窗内容控制信号需要由参数`A`和通信信息`B`共同决定，而正如上面的逻辑所说，`A`是需要监听。而`B`作为通信信息需要放在逻辑的最外层实现。所以说就出现了一个问题。`B`在最外层监听通信信息。然后回调函数来触发`A`的监听和判断，我出现这个情况，那么就有可能`B`监听到通信信息的多次改变，多次调用回调函数，那么就会出现对`A`的多次监听，多次监听多次`watch`会造成**内存泄漏**的问题。

由于js并没有实现对`watch`的卸载类似的操作，所以对于重复监听，重复`watch`解决方案一般只有将监听放在逻辑外层处理，**尽可能不要在回调中进行`watch`**。

但很明显由于逻辑的问题，我们不得不把对于参数`A`的`watch`放在通信信息`B`的回调函数内，但是对需求进行分析。我们可以了解到对于通信信息`B`的获取其实只需要一次。也就是说`buson`的挂载可以只监听一次，监听完获取完后可以将它卸载。当然卸载确实是解决了这个问题，但是如果说在短时间内多次触发了`buson`的监听，回调函数被多次触发。在卸载之前回调函数的多次`watch`仍然被执行，那么还是没有解决内存泄漏的问题。

应对这种情况，我使用锁来解决，也是进程的占用的实现，设计一个`watched`信号初始化为`false`，当`buson`的回调函数被触发，立即对监听得到的值和`watched`信号进行判断，只有`watched`信号为`false`时才能够继续执行下去，而如果能够继续执行下去，第一件事就是将`watched`信号置为`true`，那么即使后续有连续的多次回调函数被触发，也会由于这个信号实现进程的占用保证回调函数只执行一次，并且我在实现的时候，第二件事做的是之前所说的将`buson`的事件监听卸载掉，也就是`busoff`，这相当于实现了第二重保障，虽然他的效力没有刚刚的锁那么强，但是仍然是一个非常有效的手段，并且有利于资源的节约。

那么这个实现的收获是：**应该尽可能不在回调中`watch`，但如果逻辑上需要实现，那么可以通过锁来解决。**

## npm link
项目区分依赖的`npm`包和小程序，但开发的时候两边要同时进行，这个时候就需要`npm link`，因为个人项目不会有这种需求，所以我也是第一次接触。

`npm link`是将未发布的`npm`包也就是本地的代码生成一个软链接，所需要进入想要生成软链接的代码目录下使用指令`npm link`即可；

而需要使用到这个未发布的`npm`包的小程序则是使用`npm link @xxxx/yyyy`来完成对本地软链接的依赖引入。用的链接引入后，在对未发布的`npm`包本地代码进行的修改，能够被同步到链接它的项目中，非常方便。

在这个使用期间还遇到一些问题，我分析后很快就得到结论，并且验证成功了。

这个问题是当我使用`npm link`生成软链接后在小程序里引入，但是似乎都没有体现出最新版本的特性，于是经过查找，我发现可以使用这条命令:`npm ls <package_name>`，它能够以树形结构打印出要查看包的所有版本，以及它们的依赖关系，箭头会指向本地链接的实际路径，而如果像我一样使用`nvm`管理`Node`版本，路径里就会显示使用的版本：
```
your-project@1.0.0 D:\your-project
└── /Users/yourname/.nvm/versions/node/v18.18.0/lib/node_modules/xxx/yyy  # 箭头指向本地包实际路径
```
也是因为这个，我发现在`npm`包本地代码生成软链接时使用的`Node`版本和小程序的代码里使用的版本是不同的，这导致了引入时没有使用到正确的软链接，也就不是最新版本。所以及时统一到同样的node版本后项目就正常运行了。

## 项目上线
代码编写完成后将`npm`部分提交，经历mr合并并完成发布，就能够将更新到本地编写完成后的版本。

接着到小程序发布的步骤，因为小程序引用依赖了`npm`包，所以需要先发布`npm`包。然后将依赖即`package.json`中的`npm`依赖版本更新到发布后的最新版本。**npm的最新版本查看的命令是：**`npm view <package_name> versions`，可以通过这条命令查看自己的npm包是否确实发布成功。

然后重新安装依赖，可以在本地测试一下安装最新版`npm`包后的小程序运行起来是否正常，检查完成后就可以把小程序也提交，同样经历mr合并，到这里我们的任务就完成了，最后发布线上、运行就不需要我们再管了。

### 冲突与合并的处理
由于同一个项目会有大量的开发人员共同开发，各自的代码合并进入主分支的时间并不相同，所以较晚合并代码的开发人员需要从主分支更新其他开发人员更新的代码，并且处理相应的冲突（如果有的话）。一般来说，如果需要共同处理同一部分的代码，那么会将自己这边提交的更改暂存起来，然后更新同步主分支代码。之后再将自己的更改重新添加到本地代码中。而如果没有需要共同处理的代码，那么一般会发生冲突的只有`package.json`和`package-lock.json`。这两个文件冲突，那么当然就是以主分支的为准，解决冲突后，合并主分支完成，需要重新根据主分支的`package.json`安装依赖，因为重新安装依赖会清空之前的`npm link`，所以重新安装依赖之后还需要重新`npm link`。

### 插曲——ts类型修复
当我合并主分支并尝试提交自己完成的代码时，发生过一个小插曲：个人的代码提交时一切顺利，只有报告与主分支代码冲突，导致流水线暂停。于是我关闭流水线重新合并主分支代码并提交，结果发生了`eslint`检测不通过的问题；这很奇怪，这意味着目前的主分支代码存在不能通过`eslint`校验的内容。但是为什么别人没有通过校验的代码能够提交到主分支上并不是我需要关心的最主要的问题。我需要找出不符合规范的地方，并且进行处理。

这里讲一下我当时使用的**TypeScript 类型检查命令：**`npx tsc -p tsconfig.json --noEmit`，这条指令能够基于指定的`tsconfig.json`配置文件，对项目进行类型检查，但不生成编译后的`JavaScript`文件；它的输出结果能够直接定位不符合规范的地方。

最后定位到了一个很简单的问题。跟`ts`自动推断有关，一个被赋值了的字符串变量后有开发人员给他类型注解了变量类型为string，由于现在`ts`对于简单变量类型能够自动推断，因此这个注解是多余的，而`eslint`的检测并不允许这种多余的注解的存在，因此出现了这个问题。那么解决方法很简单，把这个多余的注解删掉就行了。当然这也提醒我，基础的知识还是要记牢，`eslint`的检测也不可少。

## 对“壳”的认识
正如前面所讲到的，项目区分依赖的`npm`包和小程序，其中这些`npm`包被统一放到一个大型的项目里，其实这个项目就是“壳”。壳是各个包外的一个容器，它能够一定程度上统一限制依赖的版本，这个在后面会具体地分析。

## npm依赖的使用与思考
最后讲一下`npm`依赖的问题。正如前面介绍过的，会通过包装成`npm`包的形式，让小程序按需引入，那么就会有很多的功能被拆分开来，拆分成非常多的`npm`包，然后被放到一个统一的大型项目里。

那么每个`npm`包就是一个小型项目，它们也有自己各自的依赖。但是由于他们并不是一同开发，是各自作为一个小项目，因此他们的依赖都是不受限的，那么就很容易出现同样需要某个依赖，但是他们使用了同个依赖的不同版本。那么对于引入了他们的项目，比如小程序，那么小程序就需要去下载同个依赖的不同版本，显然造成了不必要的浪费，导致项目的体积膨胀。这个问题我们管它叫做**npm版本不统一导致安装多版本依赖而产生的体积膨胀问题**。

### npm版本统一的实现与风险
那么很明显为了解决上述的问题，我们需要统一`npm`的版本。前面所讲到的“壳”其实就对这方面做了一定的限制。正如前面所介绍壳是各个包外面的一个容器。因此它可以实现对各个包的依赖，进行一个统一的管理。壳也有自己的依赖，可以说是有`package.json`和`package-lock.json`，他们会统一项目内各个包的依赖，其他项目在引用这些包时，首先从壳内对所需的版本进行获取、安装，但是可也并没有对所有的依赖都进行了约束，而且对于有些依赖也是采取了“^1.0.2”的写法，这种写法意味着依赖的安装版本仍然是灵活的，并没有受到完全严格的限制，这都是有原因的。

对于npm的版本统一，理想的情况下，我们可以对于各个包的依赖都进行检查，并且全部统一到壳的依赖中，统一采取这些依赖的最新版本，并且采用严格精确的版本进行限制。这样大刀阔斧的改革，其实能够从根源上解决问题，但是对于一个运作多年的项目来说，是具备风险的。

因为依赖的不同版本是可能存在冲突的，一个旧版本的特性在新的版本中不一定能够得到保留，如果说我们的某个组件需要使用一个较旧版本的特性，当我们把它更新到一个较新的版本，就可能导致这个组件不能够正常地工作。其实我们做严格精确的版本限制就是对依赖版本更新有可能存在这种风险所进行的预防，所以像刚刚讲到的统一所有包的依赖到最新的版本，具体说是到我们使用的所有版本中最新的一个，它也是有像上面讲到的这种导致使用旧版本依赖的组件功能不可用的风险的。并且对于一个内容庞杂，大型的项目来说，是很有可能出现这种问题的。所以说如果要进行这样的更新改革那么不管是测试也好，开发调整也好，都可能会有非常巨大的工作量。并且最终的结果可能仍然需要采用多版本的依赖。所以说npm版本的统一，是一个困难的、理想化的要求，并不是说他不可能实现，但是实现的过程一定是耗费人力物力，并且可能达不到理想结果的。

所以说目前壳的管理对实现`npm`版本统一的角度来说，应该是达到了最理想的状况了。所以关于这部分的内容，我们**最关心的还是npm版本自动更新的风险**

### npm版本自动更新的风险与预防
正如前面所说，有些依赖对安装版本采取了灵活的写法（^1.0.2），这种写法意味着如果存在比1.0.2更高的版本，那么项目在依赖安装时可能会安装更新的版本，并且它的更新是自动的、不易察觉的。而正如我们刚刚所讲一个依赖的新的版本，与旧的版本可能是存在冲突的。如果说依赖在不被察觉的情况下自动更新，那么有可能以前的项目功能代码会失效。因此如果出现依赖版本更新，开发必须要察觉了解并且进行风险评估，确保版本更新不影响项目的运行。

所以我们需要建设`npm`依赖变动识别的能力。


# 你不知道的JS-摘录-起步上路

顺便读一读[You-Dont-Know-JS](https://github.com/getify/You-Dont-Know-JS)，把一些我觉得对我比较有启发的语句摘录下来，很多重要的内容我都没有摘抄，只是因为相对而言我对它们比较熟悉，摘抄的主要是我不熟悉甚至不知道的内容，并不是说没有摘抄的内容就不重要。

另外，在极少数我觉得需要补充的地方会写一些内容，但大多数时候原内容就已经足够简单易懂了，所以基本都是摘抄

ps:目前摘录内容较少，暂时不加入侧边栏，只从顶部栏进入查看效果。等读的差不多了再放进侧边栏

## 第二章-值与类型：
在JavaScript中只有值拥有类型；变量只是这些值的简单容器。

`typeof null`是一个有趣的例子，因为当你期望它返回`"null"`时，它错误地返回了`"object"`。这是JS中一直存在的一个bug，但是看起来它永远都不会被修复了。在网络上有太多的代码依存于这个bug，因此修复它将会导致更多的bug！

### 值的比较
#### Truthy 与 Falsy
当一个非`boolean`值被强制转换为一个`boolean`时，它是变成`true`还是`false`。

在JavaScript中“falsy”的明确列表如下：

* `""` （空字符串）
* `0`, `-0`, `NaN` （非法的`number`）
* `null`, `undefined`
* `false`

任何不在这个“falsy”列表中的值都是“truthy”。

#### 等价性
`==`和`===`之间的不同通常被描述为，`==`检查值的等价性而`===`检查值和类型两者的等价性。然而，这是不准确的。描述它们的合理方式是，`==`在允许强制转换的条件下检查值的等价性，而`===`是在不允许强制转换的条件下检查值的等价性；因此`===`常被称为“严格等价”。

```
这个部分我自己想补充一下==比较的流程的总结：
==从上到下按照规则比较，直到能得到确切结果为止
1.两端类型相同，比较值
2.两端存在NaN，返回false
3. undefined和null只有与自身比较，或者互相比较时，才会返回true
4.两端都是原始类型，转换成数字比较
5.一端是原始类型，一端是对象类型，把对象转换成原始类型后进入第1步
6.两端都是对象类型直接比较引用地址是否相同
注意直接开辟的[]、{}都会在内存中开辟一块空间，因此[]==[];{}=={}都不会相等

也就是先看类型，相同直接比；
不同的话，看看有没有NaN，有的话直接false；
没有再看类型有没有对象，
    有且仅有一个的话对对象进行处理成原始类型比较；
        两个都是对象直接比引用地址是否相同；
    没有的话转数字再比较；
注意undefined和null的比较情况。

对象如何转原始类型？下面的得不到原始值就是return {}；
另外还有需要注意的地方，{}经过valueOf得到的还是对象，经过toString得到的是'[object Object]'，
因此({})==""是false，而[]==""是true
1.如果对象拥有[Symbol.toPrimitive]方法，调用该方法。
若该方法能得到原始值，使用该原始值；
若得不到原始值，抛出异常
2.调用对象的value0f方法
若该方法能得到原始值，使用该原始值；
若得不到原始值，进入下一步
3.调用对象的toString方法
若该方法能得到原始值，使用该原始值;
若得不到原始值，抛出异常
```
为了将这许多细节归纳为一个简单的包装，并帮助你在各种情况下判断是否使用`==`或`===`，这是我的简单规则：

* 如果一个比较的两个值之一可能是`true`或`false`值，避免`==`而使用`===`。
* 如果一个比较的两个值之一可能是这些具体的值（`0`，`""`，或`[]` —— 空数组），避免`==`而使用`===`。
* 在 *所有* 其他情况下，你使用`==`是安全的。它不仅安全，而且在许多情况下它可以简化你的代码并改善可读性。

这些规则归纳出来的东西要求你严谨地考虑你的代码：什么样的值可能通过这个被比较等价性的变量。如果你可以确定这些值，那么`==`就是安全的，使用它！如果你不能确定这些值，就使用`===`。就这么简单。

#### 不等价性
JavaScript`string`值也可进行不等价性比较，它使用典型的字母顺序规则（`"bar" < "foo"`）。

在可能不同类型的值之间进行比较时，你可能遇到的最大的坑 —— 记住，没有“严格不等价”可用 —— 是其中一个值不能转换为合法的数字，例如：

```js
var a = 42;
var b = "foo";

a < b;		// false
a > b;		// false
a == b;		// false
```

等一下，这三个比较怎么可能都是`false`？因为在`<`和`>`的比较中，值`b`被强制转换为了“非法的数字值”，而且语言规范说`NaN`既不大于其他值，也不小于其他值。

## 第二章-Strict模式
ES5在语言中加入了一个“strict模式”，它收紧了一些特定行为的规则。

使用strict模式的一个关键不同（改善！）是，它不允许因为省略了`var`而进行隐含的自动全局变量声明：

```js
function foo() {
	"use strict";	// 打开strict模式
	a = 1;			// 缺少`var`，ReferenceError
}

foo();
```
## 第二章-旧的与新的
### 转译
实质上，你的源代码是使用新的语法形式编写的，但是你向浏览器部署的是转译过的旧语法形式。你一般会将转译器插入到你的构建过程中，与你的代码linter和代码压缩器类似。

这是一个转译的简单例子。ES6增加了一个称为“默认参数值”的新特性。它看起来像是这样：

```js
function foo(a = 2) {
	console.log( a );
}

foo();		// 2
foo( 42 );	// 42
```

简单，对吧？也很有用！但是这种新语法在前ES6引擎中是不合法的。那么转译器将会对这段代码做什么才能使它在老版本环境中运行呢？

```js
function foo() {
	var a = arguments[0] !== (void 0) ? arguments[0] : 2;
	console.log( a );
}
```

如你所见，它检查`arguments[0]`值是否是`void 0`（也就是`undefined`），而且如果是，就提供默认值`2`；否则，它就赋值被传递的任何东西。

除了可以现在就在老版本浏览器中使用更好的语法以外，观察转译后的代码实际上更清晰地解释了意图中的行为。

仅从ES6版本的代码看来，你可能还不理解`undefined`是唯一不能作为参数默认值的明确传递的值，但是转译后的代码使这一点清楚的多。

## 第三章-作用域与闭包
*作用域与闭包* 从揭穿常见的误解开始：JS是“解释型语言”因此是不被编译的。不对。

JS引擎在你的代码执行的前一刻（有时是在执行期间！）编译它。所以我们首先深入了解编译器处理我们代码的方式，以此来理解它如何找到并处理变量和函数的声明。沿着这条道路，我们将见到JS变量作用域管理的特有隐喻，“提升”。


# 你不知道的JS-摘录-作用域与闭包
## 第一章 什么是作用域？
事实上，在变量中存储值和取出值的能力，给程序赋予了 *状态*。

但是在我们的程序中纳入变量，引出了我们现在将要解决的最有趣的问题：这些变量 *存活* 在哪里？换句话说，它们被存储在哪儿？而且，最重要的是，我们的程序如何在需要它们的时候找到它们？

回答这些问题需要一组明确定义的规则，它定义如何在某些位置存储变量，以及如何在稍后找到这些变量。我们称这组规则为：*作用域*。

## 第一章-理解作用域
### 编译器术语
在我们这个例子中，*引擎* 将会对变量 `a` 实施一个“LHS”查询。另一种类型的查询称为“RHS”。

这两个术语表示“Left-hand Side（左手边）”和“Right-hand Side（右手边）”

什么的……边？**赋值操作的。**

换言之，当一个变量出现在赋值操作的左手边时，会进行 LHS 查询，当一个变量出现在赋值操作的右手边时，会进行 RHS 查询。

实际上，我们可以表述得更准确一点儿。对于我们的目的来说，一个 RHS 是难以察觉的，因为它简单地查询某个变量的值，而 LHS 查询是试着找到变量容器本身，以便它可以赋值。从这种意义上说，RHS 的含义实质上不是 *真正的* “一个赋值的右手边”，更准确地说，它只是意味着“不是左手边”。

**注意：** LHS 和 RHS 意味着“赋值的左/右手边”未必像字面上那样意味着“ `=` 赋值操作符的左/右边”。赋值有几种其他的发生形式，所以最好在概念上将它考虑为：“赋值的目标（LHS）”和“赋值的源（RHS）”。

### 小测验
```js
function foo(a) {
	var b = a;
	return a + b;
}

var c = foo( 2 );
```

1. 找到所有的 LHS 查询（有3处！）。

2. 找到所有的 RHS 查询（有4处！）。

### 小测验答案
1. 找出所有的 LHS 查询（有3处！）。

	**`c = ..`, `a = 2`（隐含的参数赋值）和 `b = ..`**

2. 找出所有的 RHS 查询（有4处！）。

    **`foo(2..`, `= a;`, `a + ..` 和 `.. + b`**

## 第一章-错误
为什么我们区别 LHS 和 RHS 那么重要？

因为在变量还没有被声明（在所有被查询的 *作用域* 中都没找到）的情况下，这两种类型的查询的行为不同。

考虑如下代码：

```js
function foo(a) {
	console.log( a + b );
	b = a;
}

foo( 2 );
```

当 `b` 的 RHS 查询第一次发生时，它是找不到的。它被说成是一个“未声明”的变量，因为它在作用域中找不到。

如果 RHS 查询在嵌套的 *作用域* 的任何地方都找不到一个值，这会导致 *引擎* 抛出一个 `ReferenceError`。必须要注意的是这个错误的类型是 `ReferenceError`。

相比之下，如果 *引擎* 在进行一个 LHS 查询，但到达了顶层（全局 *作用域*）都没有找到它，而且如果程序没有运行在“Strict模式”[^note-strictmode]下，那么这个全局 *作用域* 将会在 **全局作用域中** 创建一个同名的新变量，并把它交还给 *引擎*。

*“不，之前没有这样的东西，但是我可以帮忙给你创建一个。”*

在 ES5 中被加入的“Strict模式”[^note-strictmode]，有许多与一般/宽松/懒惰模式不同的行为。其中之一就是不允许自动/隐含的全局变量创建。在这种情况下，将不会有全局 *作用域* 的变量交回给 LHS 查询，并且类似于 RHS 的情况, *引擎* 将抛出一个 `ReferenceError`。

现在，如果一个 RHS 查询的变量被找到了，但是你试着去做一些这个值不可能做到的事，比如将一个非函数的值作为函数运行，或者引用 `null` 或者 `undefined` 值的属性，那么 *引擎* 就会抛出一个不同种类的错误，称为 `TypeError`。

`ReferenceError` 是关于 *作用域* 解析失败的，而 `TypeError` 暗示着 *作用域* 解析成功了，但是试图对这个结果进行了一个非法/不可能的动作。

## 第二章-欺骗词法作用域
如果词法作用域是由函数被声明的位置唯一定义的，而且这个位置完全是一个编写时的决定，那么怎么可能有办法在运行时“修改”（也就是，作弊欺骗）词法作用域呢？

JavaScript 有两种这样的机制。在广大的社区中它们都等同地被认为是让人皱眉头的，在你代码中使用它们是一种差劲儿的做法。但是关于它们的常见的争论经常错过了最重要的一点：**欺骗词法作用域会导致更低下的性能。**

JavaScript 中的 `eval(..)` 函数接收一个字符串作为参数值，并将这个字符串的内容看作是好像它已经被实际编写在程序的那个位置上。换句话说，你可以用编程的方式在你编写好的代码内部生成代码，而且你可以运行这个生成的代码，就好像它在编写时就已经在那里了一样。
### `eval`
考虑如下代码：

```js
function foo(str, a) {
	eval( str ); // 作弊！
	console.log( a, b );
}

var b = 2;

foo( "var b = 3;", 1 ); // 1 3
```

在 `eval(..)` 调用的位置上，字符串 `"var b = 3"` 被看作是一直就存在在那里的代码。因为这个代码恰巧声明了一个新的变量 `b`，它就修改了现存的 `foo(..)` 的词法作用域。事实上，就像上面提到的那样，这个代码实际上在 `foo(..)` 内部创建了变量 `b`，它遮蔽了声明在外部（全局）作用域中的 `b`。

```
这部分我想自己总结一下
这里eval和with在本书原文中、MDN中都看到强调了不要使用，尤其with是直接被废弃的，
因此我甚至没有摘录关于with的使用介绍，摘录eval也只是了解一下的意思，未来不要使用
所以这部分内容也不用仔细看，夸张一点说，总体上可以直接看 复习 部分的内容
```

### 性能
JavaScript *引擎* 在编译阶段期行许多性能优化工作。其中的一些优化原理都归结为实质上在进行词法分析时可以静态地分析代码，并提前决定所有的变量和函数声明都在什么位置，这样在执行期间就可以少花些力气来解析标识符。

但如果 *引擎* 在代码中发现一个 `eval(..)` 或 `with`，它实质上就不得不 *假定* 自己知道的所有的标识符的位置可能是无效的，因为它不可能在词法分析时就知道你将会向`eval(..)`传递什么样的代码来修改词法作用域，或者你可能会向`with`传递的对象有什么样的内容来创建一个新的将被查询的词法作用域。

换句话说，悲观地看，如果 `eval(..)` 或 `with` 出现，那么它 *将* 做的几乎所有的优化都会变得没有意义，所以它就会简单地根本不做任何优化。

你的代码几乎肯定会趋于运行的更慢，只因为你在代码的任何地方引入了一个了 `eval(..)` 或 `with`。无论 *引擎* 将在努力限制这些悲观臆测的副作用上表现得多么聪明，**都没有任何办法可以绕过这个事实：没有优化，代码就运行的更慢。**

## 附录A
::: details 总结和问题发现
其实这部分主要是希望让我们明白什么是动态作用域，但我却发现我更不了解词法作用域，动态作用域简而言之就是我之前了解的`this`，从调用位置附近层层向上查找，我以为我理解了原型链，结果只是理解了逐层向上，词法作用域没有理解，从调用位置层层向上是动态作用域。词法作用域是静态，和代码结构、编写有关。

因为之前主要了解了关于this的使用，所以我实际理解的是动态作用域，但通过本书，才了解到`JS`只有词法作用域，只是`this`和动态作用域关系更紧密；

非常关键的一句话，摘录了但在这里再次强调：**词法作用域是编写时的，而动态作用域（和 `this`）是运行时的**。词法作用域关心的是 *函数在何处被声明*，但是动态作用域关心的是函数 *从何处* 被调用。

因此对于这个代码示例，之所以打印出`2`，就是因为`foo`函数的词法作用域在定义时就已确定（全局作用域），与`foo`的调用位置（本例中在`bar`内调用）无关
:::
正如我们在第二章中看到的，词法作用域是一组关于 *引擎* 如何查询变量和它在何处能够找到变量的规则。词法作用域的关键性质是，它是在代码编写时被定义的（假定你不使用 `eval()` 或 `with` 作弊的话）。

动态作用域看起来在暗示，有充分的理由，存在这样一种模型，它的作用域是在运行时被确定的，而不是在编写时静态地确定的。让我们通过代码来说明这样的实际情况：

```js
function foo() {
	console.log( a ); // 2
}

function bar() {
	var a = 3;
	foo();
}

var a = 2;

bar();
```

在 `foo()` 的词法作用域中指向 `a` 的 RHS 引用将被解析为全局变量 `a`，它将导致输出结果为值 `2`。

如果 JavaScript 拥有动态作用域，当 `foo()` 被执行时，**理论上** 下面的代码将得出 `3` 作为输出结果。

要清楚，JavaScript **实际上没有动态作用域**。它拥有词法作用域。就这么简单。但是 `this` 机制有些像动态作用域。

关键的差异：**词法作用域是编写时的，而动态作用域（和 `this`）是运行时的**。词法作用域关心的是 *函数在何处被声明*，但是动态作用域关心的是函数 *从何处* 被调用。

## 第二章-复习
在 JavaScript 中有两种机制可以“欺骗”词法作用域：`eval(..)` 和 `with`。前者可以通过对一个拥有一个或多个声明的“代码”字符串进行求值，来（在运行时）修改现存的词法作用域。后者实质上是通过将一个对象引用看作一个“作用域”，并将这个对象的属性看作作用域中的标识符，（同样，也是在运行时）创建一个全新的词法作用域。

这些机制的缺点是，它压制了 *引擎* 在作用域查询上进行编译期优化的能力，因为 *引擎* 不得不悲观地假定这样的优化是无效的。这两种特性的结果就是代码 *将* 会运行的更慢。**不要使用它们。**

## 第三章-隐藏于普通作用域
考虑一个函数的传统方式是，你声明一个函数，并在它内部添加代码。但是相反的想法也同样强大和有用：拿你所编写的代码的任意一部分，在它周围包装一个函数声明，这实质上“隐藏”了这段代码。

其实际结果是在这段代码周围创建了一个作用域气泡，这意味着现在在这段代码中的任何声明都将绑在这个新的包装函数的作用域上，而不是前一个包含它们的作用域。换句话说，你可以通过将变量和函数围在一个函数的作用域中来“隐藏”它们。

为什么“隐藏”变量和函数是一种有用的技术？

有多种原因驱使着这种基于作用域的隐藏。它们主要是由一种称为“最低权限原则”的软件设计原则引起的[^note-leastprivilege]，有时也被称为“最低授权”或“最少曝光”。这个原则规定，在软件设计中，比如一个模块/对象的API，你应当只暴露所需要的最低限度的东西，而“隐藏”其他的一切。

这个原则可以扩展到用哪个作用域来包含变量和函数的选择。如果所有的变量和函数都在全局作用域中，它们将理所当然地对任何嵌套的作用域来说都是可访问的。但这回违背“最少……”原则，因为你（很可能）暴露了许多你本应当保持为私有的变量和函数，而这些代码的恰当用法是不鼓励访问这些变量/函数的。
例如：

```js
function doSomething(a) {
	b = a + doSomethingElse( a * 2 );

	console.log( b * 3 );
}

function doSomethingElse(a) {
	return a - 1;
}

var b;

doSomething( 2 ); // 15
```

在这个代码段中，变量 `b` 和函数 `doSomethingElse(..)` 很可能是 `doSomething(..)` 如何工作的“私有”细节。允许外围的作用域“访问” `b` 和 `doSomethingElse(..)` 不仅没必要而且可能是“危险的”，因为它们可能会以种种意外的方式，有意或无意地被使用，而这也许违背了 `doSomething(..)` 假设的前提条件。

一个更“恰当”的设计是讲这些私有细节隐藏在`doSomething(..)`的作用域内部，比如：

```js
function doSomething(a) {
	function doSomethingElse(a) {
		return a - 1;
	}

	var b;

	b = a + doSomethingElse( a * 2 );

	console.log( b * 3 );
}

doSomething( 2 ); // 15
```

现在，`b` 和 `doSomethingElse(..)` 对任何外界影响都是不可访问的，而是仅仅由 `doSomething(..)` 控制。它的功能和最终结果不受影响，但是这种设计将私有细节保持为私有的，这通常被认为是好的软件。
```
这部分内容我也做一下总结，隐藏简单来说就是用函数包起来，外面不能直接使用
尤其是函数包函数，函数A内函数B只用来处理函数A内的业务，可以说成为了函数A私有的内容
当然，具体实现还要看具体需求，比如B是否需要多次复用？是否只在A内复用？
如果B需要多次复用，才有封装的需求；只在A内复用，才能被A私有。
所以感觉局限性比较大，但作为好的软件设计，思路还是要了解并记住的
```

### 避免冲突

将变量和函数“隐藏”在一个作用域内部的另一个好处是，避免两个同名但用处不同的标识符之间发生无意的冲突。冲突经常导致值被意外地覆盖。

例如：

```js
function foo() {
	function bar(a) {
		i = 3; // 在外围的for循环的作用域中改变`i`
		console.log( a + i );
	}

	for (var i=0; i<10; i++) {
		bar( i * 2 ); // 噢，无限循环！
	}
}

foo();
```

`bar(..)` 内部的赋值 `i = 3` 意外地覆盖了在 `foo(..)` 的for循环中声明的 `i`。在这个例子中，这将导致一个无限循环，因为 `i` 被设定为固定的值 `3`，而它将永远 `< 10`。

`bar(..)` 内部的赋值需要声明一个本地变量来使用，不论选用什么样的标识符名称。`var i = 3;` 将修复这个问题（并将为 `i` 创建一个前面提到的“遮蔽变量”声明）。一个 *另外的* 选项，不是代替的选项，是完全选择另外一个标识符名称，比如 `var j = 3;`。但是你的软件设计也许会自然而然地使用相同的标识符名称，所以在这种情况下利用作用域来“隐藏”你的内部声明是你最好/唯一的选择。
```
就是说要么用var i = 3；这样作用域就只在bar()中——局部变量，不影响到foo()里的i；
要么干脆用j；不同名字变量肯定不覆盖
跟这里讲的隐藏有关系的就是bar里面的i，只要用var i就实现了通过外部包函数(bar)来隐藏的目的
```
#### 全局“名称空间”
变量冲突（很可能）发生的一个特别强有力的例子是在全局作用域中。当多个库被加载到你的程序中时，如果它们没有适当地隐藏它们的内部/私有函数和变量，那么它们可以十分容易地互相冲突。

这样的库通常会在全局作用域中使用一个足够独特的名称来创建一个单独的变量声明，它经常是一个对象。然后这个对象被用作这个库的一个“名称空间”，所有要明确暴露出来的功能都被作为属性挂在这个对象（名称空间）上，而不是将它们自身作为顶层词法作用域的标识符。

例如：

```js
var MyReallyCoolLibrary = {
	awesome: "stuff",
	doSomething: function() {
		// ...
	},
	doAnotherThing: function() {
		// ...
	}
};
```
#### 模块管理

另一种回避冲突的选择是通过任意一种依赖管理器，使用更加现代的“模块”方式。使用这些工具，没有库可以向全局作用域添加任何标识符，取而代之的是使用依赖管理器的各种机制，要求库的标识符被明确地导入到另一个指定的作用域中。

应该可以看到，这些工具并不拥有可以豁免于词法作用域规则的“魔法”功能。它们简单地使用这里讲解的作用域规则，来强制标识符不会被注入任何共享的作用域，而是保持在私有的，不易冲突的作用域中，这防止了任何意外的作用域冲突。

## 第三章-函数作为作用域

我们已经看到，我们可以拿来一段代码并在它周围包装一个函数，而这实质上对外部作用域“隐藏”了这个函数内部作用域包含的任何变量或函数声明。

例如：

```js
var a = 2;

function foo() { // <-- 插入这个

	var a = 3;
	console.log( a ); // 3

} // <-- 和这个
foo(); // <-- 还有这个

console.log( a ); // 2
```

虽然这种技术“可以工作”，但它不一定非常理想。它引入了几个问题。首先是我们不得不声明一个命名函数 `foo()`，这意味着这个标识符名称 `foo` 本身就“污染”了外围作用域（在这个例子中是全局）。我们要不得不通过名称（`foo()`）明确地调用这个函数来使被包装的代码真正运行。

如果这个函数不需要名称（或者，这个名称不污染外围作用域），而且如果这个函数能自动地被执行就更理想了。

幸运的是，JavaScript 给这两个问题提供了一个解决方法。

```js
var a = 2;

(function foo(){ // <-- 插入这个

	var a = 3;
	console.log( a ); // 3

})(); // <-- 和这个

console.log( a ); // 2
```

让我们分析一下这里发生了什么。

首先注意，与仅仅是 `function...` 相对，这个包装函数语句以 `(function...` 开头。虽然这看起来像是一个微小的细节，但实际上这是一个重大改变。与将这个函数视为一个标准的声明不同的是，这个函数被视为一个函数表达式。

**注意：** 区分声明与表达式的最简单的方法是，这个语句中（不仅仅是一行，而是一个独立的语句）“function”一词的位置。如果“function”是这个语句中的第一个东西，那么它就是一个函数声明。否则，它就是一个函数表达式。

这里我们可以观察到一个函数声明和一个函数表达式之间的关键不同是，它的名称作为一个标识符被绑定在何处。

比较这前两个代码段。在第一个代码段中，名称 `foo` 被绑定在外围作用域中，我们用 `foo()` 直接调用它。在第二个代码段中，名称 `foo` 没有被绑定在外围作用域中，而是被绑定在它自己的函数内部。

换句话说，`(function foo(){ .. })` 作为一个表达式意味着标识符 `foo` 仅能在 `..` 代表的作用域中被找到，而不是在外部作用域中。将名称 `foo` 隐藏在它自己内部意味着它不会没必要地污染外围作用域。
::: details 提醒自己一下，上面这部分要仔细看
对我来说是很不错的讲解，因为关于立即执行函数的内容都是之前遇到临时学的，并不扎实，现在可以更好地理解了

虽然原文下面有更详细的关于立即执行函数的讲解，但上面这部分内容对我来说就足够了，下面主要就是一些变种和命名匿名的选择，并不重要，摘抄太多反而啰嗦
:::

## 第三章-块级作为作用域
这就是有关块级作用域的一切。尽可能靠近地，尽可能局部地，在变量将被使用的位置声明它。另一个例子是：

```js
var foo = true;

if (foo) {
	var bar = foo * 2;
	bar = something( bar );
	console.log( bar );
}
```

我们仅在 if 语句的上下文环境中使用变量 `bar`，所以我们将它声明在 if 块级的内部是有些道理的。然而，当使用 `var` 时，我们在何处声明变量是无关紧要的，因为它们将总是属于外围作用域。这个代码段实质上为了代码风格的原因“假冒”了块级作用域，并依赖于我们要管好自己，不要在这个作用域的其他地方意外地使用 `bar`。

::: details 总结与注意
说了一大堆，这里的`bar`仍然是全局变量，`if`外仍然可以获取`bar`，原因很简单，想要块级作用域得用`let`、`const`，如果`var`这样能实现块级作用域，那`ES6`还折腾那么多干嘛？原文的意思是这只是代码风格，依赖于我们自己管理，没有实际块级作用域效果，这里原文写的太啰嗦反而显得容易误导，道理就是我写的这么简单。
:::
### `try/catch`

一个鲜为人知的事实是，JavaScript 在 ES3 中明确指出在 `try/catch` 的 `catch` 子句中声明的变量，是属于 `catch` 块级的块级作用域的。

例如：

```js
try {
	undefined(); //用非法的操作强制产生一个异常！
}
catch (err) {
	console.log( err ); // 好用！
}

console.log( err ); // ReferenceError: `err` not found
```

如你所见，`err` 仅存在于 `catch` 子句中，并且在你试着从其他地方引用它时抛出一个错误。

**注意：** 虽然这种行为已经被明确规定，而且对于几乎所有的标准JS环境（也许除了老IE）来说都是成立的，但是如果你在同一个作用域中有两个或多个 `catch` 子句，而它们又各自用相同的标识符名称声明了它们表示错误的变量时，许多 linter 依然会报警。实际上这不是重定义，因为这些变量都安全地位于块级作用域中，但是 linter 看起来依然会恼人地抱怨这个事实。

为了避免这些不必要的警告，一些开发者将他们的 `catch` 变量命名为 `err1`，`err2`，等等。另一些开发者干脆关闭 linter 对重复变量名的检查。

`catch` 的块级作用域性质看起来像是一个没用的，只有学院派意义的事实，但是参看附录B来了解更多它如何有用的信息。

### `let`
#### 垃圾回收

块级作用域的另一个有用之处是关于闭包和释放内存的垃圾回收。我们将简单地在这里展示一下，但是闭包机制将在第五章中详细讲解。

考虑这段代码：

```js
function process(data) {
	// 做些有趣的事
}

var someReallyBigData = { .. };

process( someReallyBigData );

var btn = document.getElementById( "my_button" );

btn.addEventListener( "click", function click(evt){
	console.log("button clicked");
}, /*capturingPhase=*/false );
```

点击事件的处理器回调函数 `click` 根本不 *需要* `someReallyBigData` 变量。这意味着从理论上讲，在 `process(..)` 运行之后，这个消耗巨大内存的数据结构可以被作为垃圾回收。然而，JS引擎很可能（虽然这要看具体实现）仍会将这个结构保持一段时间，因为`click`函数在整个作用域上拥有一个闭包。

块级作用域可以解决这个问题，使引擎清楚地知道它不必再保持 `someReallyBigData` 了：

```js
function process(data) {
	// 做些有趣的事
}

// 运行过后，任何定义在这个块中的东西都可以消失了
{
	let someReallyBigData = { .. };

	process( someReallyBigData );
}

var btn = document.getElementById( "my_button" );

btn.addEventListener( "click", function click(evt){
	console.log("button clicked");
}, /*capturingPhase=*/false );
```

声明可以将变量绑定在本地的明确的块级是一种强大的工具，你可以把它加入你的工具箱。
::: details 总结
注意区分这里的`{}`达到的效果和[之前](#第三章-块级作为作用域)在`if`内声明变量的那种没有实际作用的效果，就知道关键在于`let`了；

另外，正是有这里`{}`的代码块划分的作用，所以之前写`{}=={}`会直接报错，因为会被理解成代码块，需要写成`({})==...`
:::

## 第四章-函数优先
::: details 提示修正
这个章节讲的是提升，有变量提升、函数提升，我比较熟悉，看过一遍感觉没什么需要摘抄的，不过遇到一个比较疑惑的点，经过验证我的想法是对的，而书中也提到未来会修改，看来对于当时而言的“未来的修改”在我读这本书的时候已经到来了

对于我阅读并发现异常的时候，下面的代码运行时已经会报错：`Uncaught TypeError: foo is not a function`，并不会给出注释的“b”

原因很简单，如果这个`function`的声明会提升，那`if(a)`也会提前执行，这显然违反常理，这部分代码就应该自上而下正常执行，按序`a`被赋值，然后进入判定语句，最后根据`a`给出函数声明；那么最开始调用的时候`foo`当然还没有声明，一定会报错。

下面是原文
:::
在同一个作用域内的重复定义是一个十分差劲儿的主意，而且经常会导致令人困惑的结果。

在普通的块级内部出现的函数声明一般会被提升至外围的作用域，而不是像这段代码暗示的那样有条件地被定义：

```js
foo(); // "b"

var a = true;
if (a) {
   function foo() { console.log( "a" ); }
}
else {
   function foo() { console.log( "b" ); }
}
```

然而，重要的是要注意这种行为是不可靠的，而且是未来版本的 JavaScript 将要改变的对象，所以避免在块级中声明函数可能是最好的做法。（再次提醒，这里有误，要看我写的修正！）


## 第五章-事实真相
为了理解和识别闭包，这里有一个你需要知道的简单粗暴的定义：

> 闭包就是函数能够记住并访问它的词法作用域，即使当这个函数在它的词法作用域之外执行时。

让我们跳进代码来说明这个定义：

```js
function foo() {
	var a = 2;

	function bar() {
		console.log( a ); // 2
	}

	bar();
}

foo();
```

根据我们对嵌套作用域的讨论，这段代码应当看起来很熟悉。由于词法作用域查询规则（在这个例子中，是一个 RHS 引用查询），函数 `bar()` 可以 *访问* 外围作用域的变量 `a`。

这是“闭包”吗？

好吧，从技术上讲…… *也许是*。但是根据我们上面的“你需要知道”的定义…… *不确切*。我认为解释 `bar()` 引用 `a` 的最准确的方式是根据词法作用域查询规则，但是那些规则 *仅仅* 是闭包的（一个很重要的！）**一部分**。

从纯粹的学院派角度讲，上面的代码段被认为是函数 `bar()` 在函数 `foo()` 的作用域上有一个 *闭包*（而且实际上，它甚至对其他的作用域也可以访问，比如这个例子中的全局作用域）。换一种略有不同的说法是，`bar()` 闭住了 `foo()` 的作用域。为什么？因为 `bar()` 嵌套地出现在 `foo()` 内部。就这么简单。

但是，这样一来闭包的定义就是不能直接 *观察到* 的了，我们也不能看到闭包在这个代码段中 *被行使*。我们清楚地看到词法作用域，但是闭包仍然像代码后面谜一般的模糊阴影。
::: details 简化
上面这部分啰嗦的内容有些多余，主要是和下面的代码对比，上面的代码也是闭包，但是效果不够明显，罗里吧嗦的这段话就是我说的这个意思

重点在于理解上面的定义
:::


让我们考虑这段将闭包完全带到聚光灯下的代码：

```js
function foo() {
	var a = 2;

	function bar() {
		console.log( a );
	}

	return bar;
}

var baz = foo();

baz(); // 2 -- 哇噢，看到闭包了，伙计。
```

函数 `bar()` 对于 `foo()` 内的作用域拥有词法作用域访问权。但是之后，我们拿起 `bar()`，这个函数本身，将它像 *值* 一样传递。在这个例子中，我们 `return` `bar` 引用的函数对象本身。

在执行 `foo()` 之后，我们将它返回的值（我们的内部 `bar()` 函数）赋予一个称为 `baz` 的变量，然后我们实际地调用 `baz()`，这将理所当然地调用我们内部的函数 `bar()`，只不过是通过一个不同的标识符引用。

`bar()` 被执行了，必然的。但是在这个例子中，它是在它被声明的词法作用域 *外部* 被执行的。

`foo()` 被执行之后，一般说来我们会期望 `foo()` 的整个内部作用域都将消失，因为我们知道 *引擎* 启用了 *垃圾回收器* 在内存不再被使用时来回收它们。因为很显然 `foo()` 的内容不再被使用了，所以看起来它们很自然地应该被认为是 *消失了*。

但是闭包的“魔法”不会让这发生。内部的作用域实际上 *依然* “在使用”，因此将不会消失。谁在使用它？**函数 `bar()` 本身。**

有赖于它被声明的位置，`bar()` 拥有一个词法作用域闭包覆盖着 `foo()` 的内部作用域，闭包为了能使 `bar()` 在以后任意的时刻可以引用这个作用域而保持它的存在。

**`bar()` 依然拥有对那个作用域的引用，而这个引用称为闭包。**

所以，在几微秒之后，当变量 `baz` 被调用时（调用我们最开始标记为 `bar` 的内部函数），它理所应当地对编写时的词法作用域拥有 *访问* 权，所以它可以如我们所愿地访问变量 `a`。

这个函数在它被编写时的词法作用域之外被调用。**闭包** 使这个函数可以继续访问它在编写时被定义的词法作用域。

当然，函数可以被作为值传递，而且实际上在其他位置被调用的所有各种方式，都是观察/行使闭包的例子。

```js
function foo() {
	var a = 2;

	function baz() {
		console.log( a ); // 2
	}

	bar( baz );
}

function bar(fn) {
	fn(); // 看妈妈，我看到闭包了！
}
```

我们将内部函数 `baz` 传递给 `bar`，并调用这个内部函数（现在被标记为 `fn`），当我们这么做时，它覆盖在 `foo()` 内部作用域的闭包就可以通过 `a` 的访问观察到。

这样的函数传递也可以是间接的。

```js
var fn;

function foo() {
	var a = 2;

	function baz() {
		console.log( a );
	}

	fn = baz; // 将`baz`赋值给一个全局变量
}

function bar() {
	fn(); // 看妈妈，我看到闭包了！
}

foo();

bar(); // 2
```

无论我们使用什么方法将内部函数 *传送* 到它的词法作用域之外，它都将维护一个指向它最开始被声明时的作用域的引用，而且无论我们什么时候执行它，这个闭包就会被行使。


# 注意
后续的话把自己的总结等部分内容改用折叠演示结果写，不要用代码模式，不然看起来不舒服而且写的时候总是要顾及每行字体的长度，太麻烦


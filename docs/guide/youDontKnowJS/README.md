# 你不知道的JS-摘录-起步上路

顺便读一读[You-Dont-Know-JS](https://github.com/getify/You-Dont-Know-JS)，把一些我觉得对我比较有启发的语句摘录下来，很多重要的内容我都没有摘抄，只是因为相对而言我对它们比较熟悉，摘抄的主要是我不熟悉甚至不知道的内容，并不是说没有摘抄的内容就不重要。

另外，在极少数我觉得需要补充的地方会写一些内容，但大多数时候原内容就已经足够简单易懂了，所以基本都是摘抄

ps:目前摘录内容较少，暂时不加入侧边栏，只从顶部栏进入查看效果。等读的差不多了再放进侧边栏

## 第二章-值与类型：
在JavaScript中只有值拥有类型；变量只是这些值的简单容器。

`typeof null`是一个有趣的例子，因为当你期望它返回`"null"`时，它错误地返回了`"object"`。这是JS中一直存在的一个bug，但是看起来它永远都不会被修复了。在网络上有太多的代码依存于这个bug，因此修复它将会导致更多的bug！

### 值的比较
#### Truthy 与 Falsy
当一个非`boolean`值被强制转换为一个`boolean`时，它是变成`true`还是`false`。

在JavaScript中“falsy”的明确列表如下：

* `""` （空字符串）
* `0`, `-0`, `NaN` （非法的`number`）
* `null`, `undefined`
* `false`

任何不在这个“falsy”列表中的值都是“truthy”。

#### 等价性
`==`和`===`之间的不同通常被描述为，`==`检查值的等价性而`===`检查值和类型两者的等价性。然而，这是不准确的。描述它们的合理方式是，`==`在允许强制转换的条件下检查值的等价性，而`===`是在不允许强制转换的条件下检查值的等价性；因此`===`常被称为“严格等价”。

```
这个部分我自己想补充一下==比较的流程的总结：
==从上到下按照规则比较，直到能得到确切结果为止
1.两端类型相同，比较值
2.两端存在NaN，返回false
3. undefined和null只有与自身比较，或者互相比较时，才会返回true
4.两端都是原始类型，转换成数字比较
5.一端是原始类型，一端是对象类型，把对象转换成原始类型后进入第1步
6.两端都是对象类型直接比较引用地址是否相同
注意直接开辟的[]、{}都会在内存中开辟一块空间，因此[]==[];{}=={}都不会相等

也就是先看类型，相同直接比；
不同的话，看看有没有NaN，有的话直接false；
没有再看类型有没有对象，
    有且仅有一个的话对对象进行处理成原始类型比较；
        两个都是对象直接比引用地址是否相同；
    没有的话转数字再比较；
注意undefined和null的比较情况。

对象如何转原始类型？下面的得不到原始值就是return {}；
另外还有需要注意的地方，{}经过valueOf得到的还是对象，经过toString得到的是'[object Object]'，
因此({})==""是false，而[]==""是true
1.如果对象拥有[Symbol.toPrimitive]方法，调用该方法。
若该方法能得到原始值，使用该原始值；
若得不到原始值，抛出异常
2.调用对象的value0f方法
若该方法能得到原始值，使用该原始值；
若得不到原始值，进入下一步
3.调用对象的toString方法
若该方法能得到原始值，使用该原始值;
若得不到原始值，抛出异常
```
为了将这许多细节归纳为一个简单的包装，并帮助你在各种情况下判断是否使用`==`或`===`，这是我的简单规则：

* 如果一个比较的两个值之一可能是`true`或`false`值，避免`==`而使用`===`。
* 如果一个比较的两个值之一可能是这些具体的值（`0`，`""`，或`[]` —— 空数组），避免`==`而使用`===`。
* 在 *所有* 其他情况下，你使用`==`是安全的。它不仅安全，而且在许多情况下它可以简化你的代码并改善可读性。

这些规则归纳出来的东西要求你严谨地考虑你的代码：什么样的值可能通过这个被比较等价性的变量。如果你可以确定这些值，那么`==`就是安全的，使用它！如果你不能确定这些值，就使用`===`。就这么简单。

#### 不等价性
JavaScript`string`值也可进行不等价性比较，它使用典型的字母顺序规则（`"bar" < "foo"`）。

在可能不同类型的值之间进行比较时，你可能遇到的最大的坑 —— 记住，没有“严格不等价”可用 —— 是其中一个值不能转换为合法的数字，例如：

```js
var a = 42;
var b = "foo";

a < b;		// false
a > b;		// false
a == b;		// false
```

等一下，这三个比较怎么可能都是`false`？因为在`<`和`>`的比较中，值`b`被强制转换为了“非法的数字值”，而且语言规范说`NaN`既不大于其他值，也不小于其他值。

## 第二章-Strict模式
ES5在语言中加入了一个“strict模式”，它收紧了一些特定行为的规则。

使用strict模式的一个关键不同（改善！）是，它不允许因为省略了`var`而进行隐含的自动全局变量声明：

```js
function foo() {
	"use strict";	// 打开strict模式
	a = 1;			// 缺少`var`，ReferenceError
}

foo();
```
## 第二章-旧的与新的
### 转译
实质上，你的源代码是使用新的语法形式编写的，但是你向浏览器部署的是转译过的旧语法形式。你一般会将转译器插入到你的构建过程中，与你的代码linter和代码压缩器类似。

这是一个转译的简单例子。ES6增加了一个称为“默认参数值”的新特性。它看起来像是这样：

```js
function foo(a = 2) {
	console.log( a );
}

foo();		// 2
foo( 42 );	// 42
```

简单，对吧？也很有用！但是这种新语法在前ES6引擎中是不合法的。那么转译器将会对这段代码做什么才能使它在老版本环境中运行呢？

```js
function foo() {
	var a = arguments[0] !== (void 0) ? arguments[0] : 2;
	console.log( a );
}
```

如你所见，它检查`arguments[0]`值是否是`void 0`（也就是`undefined`），而且如果是，就提供默认值`2`；否则，它就赋值被传递的任何东西。

除了可以现在就在老版本浏览器中使用更好的语法以外，观察转译后的代码实际上更清晰地解释了意图中的行为。

仅从ES6版本的代码看来，你可能还不理解`undefined`是唯一不能作为参数默认值的明确传递的值，但是转译后的代码使这一点清楚的多。

## 第三章-作用域与闭包
*作用域与闭包* 从揭穿常见的误解开始：JS是“解释型语言”因此是不被编译的。不对。

JS引擎在你的代码执行的前一刻（有时是在执行期间！）编译它。所以我们首先深入了解编译器处理我们代码的方式，以此来理解它如何找到并处理变量和函数的声明。沿着这条道路，我们将见到JS变量作用域管理的特有隐喻，“提升”。


# 你不知道的JS-摘录-作用域与闭包
## 第一章 什么是作用域？
事实上，在变量中存储值和取出值的能力，给程序赋予了 *状态*。

但是在我们的程序中纳入变量，引出了我们现在将要解决的最有趣的问题：这些变量 *存活* 在哪里？换句话说，它们被存储在哪儿？而且，最重要的是，我们的程序如何在需要它们的时候找到它们？

回答这些问题需要一组明确定义的规则，它定义如何在某些位置存储变量，以及如何在稍后找到这些变量。我们称这组规则为：*作用域*。

## 第一章-理解作用域
### 编译器术语
在我们这个例子中，*引擎* 将会对变量 `a` 实施一个“LHS”查询。另一种类型的查询称为“RHS”。

这两个术语表示“Left-hand Side（左手边）”和“Right-hand Side（右手边）”

什么的……边？**赋值操作的。**

换言之，当一个变量出现在赋值操作的左手边时，会进行 LHS 查询，当一个变量出现在赋值操作的右手边时，会进行 RHS 查询。

实际上，我们可以表述得更准确一点儿。对于我们的目的来说，一个 RHS 是难以察觉的，因为它简单地查询某个变量的值，而 LHS 查询是试着找到变量容器本身，以便它可以赋值。从这种意义上说，RHS 的含义实质上不是 *真正的* “一个赋值的右手边”，更准确地说，它只是意味着“不是左手边”。

**注意：** LHS 和 RHS 意味着“赋值的左/右手边”未必像字面上那样意味着“ `=` 赋值操作符的左/右边”。赋值有几种其他的发生形式，所以最好在概念上将它考虑为：“赋值的目标（LHS）”和“赋值的源（RHS）”。

### 小测验
```js
function foo(a) {
	var b = a;
	return a + b;
}

var c = foo( 2 );
```

1. 找到所有的 LHS 查询（有3处！）。

2. 找到所有的 RHS 查询（有4处！）。

### 小测验答案
1. 找出所有的 LHS 查询（有3处！）。

	**`c = ..`, `a = 2`（隐含的参数赋值）和 `b = ..`**

2. 找出所有的 RHS 查询（有4处！）。

    **`foo(2..`, `= a;`, `a + ..` 和 `.. + b`**

## 第一章-错误
为什么我们区别 LHS 和 RHS 那么重要？

因为在变量还没有被声明（在所有被查询的 *作用域* 中都没找到）的情况下，这两种类型的查询的行为不同。

考虑如下代码：

```js
function foo(a) {
	console.log( a + b );
	b = a;
}

foo( 2 );
```

当 `b` 的 RHS 查询第一次发生时，它是找不到的。它被说成是一个“未声明”的变量，因为它在作用域中找不到。

如果 RHS 查询在嵌套的 *作用域* 的任何地方都找不到一个值，这会导致 *引擎* 抛出一个 `ReferenceError`。必须要注意的是这个错误的类型是 `ReferenceError`。

相比之下，如果 *引擎* 在进行一个 LHS 查询，但到达了顶层（全局 *作用域*）都没有找到它，而且如果程序没有运行在“Strict模式”[^note-strictmode]下，那么这个全局 *作用域* 将会在 **全局作用域中** 创建一个同名的新变量，并把它交还给 *引擎*。

*“不，之前没有这样的东西，但是我可以帮忙给你创建一个。”*

在 ES5 中被加入的“Strict模式”[^note-strictmode]，有许多与一般/宽松/懒惰模式不同的行为。其中之一就是不允许自动/隐含的全局变量创建。在这种情况下，将不会有全局 *作用域* 的变量交回给 LHS 查询，并且类似于 RHS 的情况, *引擎* 将抛出一个 `ReferenceError`。

现在，如果一个 RHS 查询的变量被找到了，但是你试着去做一些这个值不可能做到的事，比如将一个非函数的值作为函数运行，或者引用 `null` 或者 `undefined` 值的属性，那么 *引擎* 就会抛出一个不同种类的错误，称为 `TypeError`。

`ReferenceError` 是关于 *作用域* 解析失败的，而 `TypeError` 暗示着 *作用域* 解析成功了，但是试图对这个结果进行了一个非法/不可能的动作。